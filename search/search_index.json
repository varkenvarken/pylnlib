{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pylnlib A python library to monitor LocoNet traffic on a usb/serial bus. table of contents intro goals architecture Message and Interface classes The Scrollkeeper class The Script and Throttle classes The Sensor, Switch and Slot classes dependencies installation example programs capture and replay webapp reference intro I am automating my layout with several Digikeijs components ( DR5000 , DR4024 , DR4088CS ) and I want to be able to script part of the running operation. Now JMRI works fine and even allows for Python scripting, but I find it a bit top heavy on a RaspberryPi 3B+ and also, although this may be a matter of taste, the Python bindings are not very pythonic nor very logical IMHO. Still, a lot of effort went into JMRI and otherwise it is a fine piece of software, but writing my own LocoNet Python library from scratch is not only a nice personal learning experience, but also might allow me to move some of it to microcontrollers with micro Python. goals The functional goals for pylnlib are - be able to monitor all traffic on the usb loconet buffer interface of the DR5000 this includes some extensions like the extended function messages (opcodes a3 and d4) generated by many throttles. to this end classes are provided that represent most messages as well as an UnknownMessage class for messages we do not recognize yet, or are not interested in (like those for CV programming for example) - be able to control switches and locomotives generate messages to change the state of a switch and to change the speed, diection and decoder function of a locomotive. - provide a Script object that simplifies the automated operation of switches and locomotives. non goals and scope There are currently no plans to implement any CV programming options nor do we aim for completeness in controlling locomotives. For example, no functionality is provided to control 'consists'. architecture Pylnlib is designed around the Message and Interface classes. Message and Interface classes Message is subclassed for every implemented LocoNet message (a.k.a. opcode) and Interface communicates over a pyserial interface with the command station. Interface converts incoming raw bytes to (subclasses of) Message instances and converts outgoing Message instance to raw bytes. Interface is thread safe and manages all input and output through two queues. Other class instances, like the Scrollkeeper , can register a callback with an instance of an Interface that will be called for every incoming message. The Scrollkeeper class The Scrollkeeper class is designed to keep track of the layout status. It does this by registering a callback function with an instance of Interface and look at every incoming Message for changes in the status of sensors, switches and slots. Status reply messages are used to update information about the item, just like commands. However if a command (like throwing a switch or changing the contents of a slot to change a locomotive's speed) references an unknown item, the Scrollkeeper instance will send an appropriate status request message. The reply to this message will then be processed as normal. For any item it receieves information about (a sensor, switch, or slot) it creates or updates a suitable object in one of the collections it manages. The Scrollkeeper class also offers methods to provide information about the status of the items it keeps updated and to forward an outgoing Message to an Interface . The Scrollkeeper class is also thread safe, so a single instance could provide information to multiple instances od a Script . Thread safety is maintained by locks on the collections of slots, switches and sensors. The Script and Throttle classes The Script class is used to automate operations on a layout. It holds a reference to a Scrollkeeper instance and provides methods to change locomotive speed, direction and functions, throw swithces as well as wait for a sensor to change to a certain state. The Throttle class is a utility class that encapsulates control of a single locomotive It is instantiated by calling a factory function in the Script class. Instantiation will also reserve a slot for the locomotive if this is not present yet and establish control by issueing a null move on that slot. The Sensor, Switch and Slot classes The Scrollkeeper class maintains several colections of objects that represent the state of an automated object. The Sensor and Switch objects are fairly simple and represent on/off and thrown/closed states respectively. The Slot object is a little more complicated as it carries much more information. It represents a slot on the active LocoNet 'stack'. In the LocoNet model you do not address locomotives directly but instead a collection of slots is kept that contains the current information about locomotives. The command station uses this information the repeatedly send DCC messages to the track. One of the pieces of information in a slot is the decoder address of the locomotiv. Other information that is kept is the diection, speed and the state of the first 9 decoder functions. The Slot class extends this by also storing the state of decoder functions 10 and up. dependencies Python 3.8 pyserial fastapi (optional, used for the webserver) installation A basic installation of just the library pip install pylnlib Installation with support for the webserver pip install pylnlib [ webserver ] example programs A simple monitor program can be run directly python \u2013m pylnlib This program can also capture and store the network data to a file and replay this file. For more options type python -m pylnlib --help The scripts directory also contains sample programs that use the library and automate some activities. capture and replay The pylnlib library can also capture raw LocoNet bytes and store it for later replay in a file. This can be really helpful when developing scripts. More details can be found here capture_and_replay.md webapp at some point a webapp will be implemented to show layout status and start cripts. Some details are provided in Webserver.md reference LocoNet personal edition [Pdf] A better formatted version of the above DCC wiki on the electrical side of LocoNet JMRI's constant defintions that include the \u00dchlenbrock extended opcodes","title":"Home"},{"location":"#pylnlib","text":"A python library to monitor LocoNet traffic on a usb/serial bus.","title":"pylnlib"},{"location":"#table-of-contents","text":"intro goals architecture Message and Interface classes The Scrollkeeper class The Script and Throttle classes The Sensor, Switch and Slot classes dependencies installation example programs capture and replay webapp reference","title":"table of contents"},{"location":"#intro","text":"I am automating my layout with several Digikeijs components ( DR5000 , DR4024 , DR4088CS ) and I want to be able to script part of the running operation. Now JMRI works fine and even allows for Python scripting, but I find it a bit top heavy on a RaspberryPi 3B+ and also, although this may be a matter of taste, the Python bindings are not very pythonic nor very logical IMHO. Still, a lot of effort went into JMRI and otherwise it is a fine piece of software, but writing my own LocoNet Python library from scratch is not only a nice personal learning experience, but also might allow me to move some of it to microcontrollers with micro Python.","title":"intro"},{"location":"#goals","text":"The functional goals for pylnlib are - be able to monitor all traffic on the usb loconet buffer interface of the DR5000 this includes some extensions like the extended function messages (opcodes a3 and d4) generated by many throttles. to this end classes are provided that represent most messages as well as an UnknownMessage class for messages we do not recognize yet, or are not interested in (like those for CV programming for example) - be able to control switches and locomotives generate messages to change the state of a switch and to change the speed, diection and decoder function of a locomotive. - provide a Script object that simplifies the automated operation of switches and locomotives.","title":"goals"},{"location":"#non-goals-and-scope","text":"There are currently no plans to implement any CV programming options nor do we aim for completeness in controlling locomotives. For example, no functionality is provided to control 'consists'.","title":"non goals and scope"},{"location":"#architecture","text":"Pylnlib is designed around the Message and Interface classes.","title":"architecture"},{"location":"#message-and-interface-classes","text":"Message is subclassed for every implemented LocoNet message (a.k.a. opcode) and Interface communicates over a pyserial interface with the command station. Interface converts incoming raw bytes to (subclasses of) Message instances and converts outgoing Message instance to raw bytes. Interface is thread safe and manages all input and output through two queues. Other class instances, like the Scrollkeeper , can register a callback with an instance of an Interface that will be called for every incoming message.","title":"Message and Interface classes"},{"location":"#the-scrollkeeper-class","text":"The Scrollkeeper class is designed to keep track of the layout status. It does this by registering a callback function with an instance of Interface and look at every incoming Message for changes in the status of sensors, switches and slots. Status reply messages are used to update information about the item, just like commands. However if a command (like throwing a switch or changing the contents of a slot to change a locomotive's speed) references an unknown item, the Scrollkeeper instance will send an appropriate status request message. The reply to this message will then be processed as normal. For any item it receieves information about (a sensor, switch, or slot) it creates or updates a suitable object in one of the collections it manages. The Scrollkeeper class also offers methods to provide information about the status of the items it keeps updated and to forward an outgoing Message to an Interface . The Scrollkeeper class is also thread safe, so a single instance could provide information to multiple instances od a Script . Thread safety is maintained by locks on the collections of slots, switches and sensors.","title":"The Scrollkeeper class"},{"location":"#the-script-and-throttle-classes","text":"The Script class is used to automate operations on a layout. It holds a reference to a Scrollkeeper instance and provides methods to change locomotive speed, direction and functions, throw swithces as well as wait for a sensor to change to a certain state. The Throttle class is a utility class that encapsulates control of a single locomotive It is instantiated by calling a factory function in the Script class. Instantiation will also reserve a slot for the locomotive if this is not present yet and establish control by issueing a null move on that slot.","title":"The Script and Throttle classes"},{"location":"#the-sensor-switch-and-slot-classes","text":"The Scrollkeeper class maintains several colections of objects that represent the state of an automated object. The Sensor and Switch objects are fairly simple and represent on/off and thrown/closed states respectively. The Slot object is a little more complicated as it carries much more information. It represents a slot on the active LocoNet 'stack'. In the LocoNet model you do not address locomotives directly but instead a collection of slots is kept that contains the current information about locomotives. The command station uses this information the repeatedly send DCC messages to the track. One of the pieces of information in a slot is the decoder address of the locomotiv. Other information that is kept is the diection, speed and the state of the first 9 decoder functions. The Slot class extends this by also storing the state of decoder functions 10 and up.","title":"The Sensor, Switch and Slot classes"},{"location":"#dependencies","text":"Python 3.8 pyserial fastapi (optional, used for the webserver)","title":"dependencies"},{"location":"#installation","text":"A basic installation of just the library pip install pylnlib Installation with support for the webserver pip install pylnlib [ webserver ]","title":"installation"},{"location":"#example-programs","text":"A simple monitor program can be run directly python \u2013m pylnlib This program can also capture and store the network data to a file and replay this file. For more options type python -m pylnlib --help The scripts directory also contains sample programs that use the library and automate some activities.","title":"example programs"},{"location":"#capture-and-replay","text":"The pylnlib library can also capture raw LocoNet bytes and store it for later replay in a file. This can be really helpful when developing scripts. More details can be found here capture_and_replay.md","title":"capture and replay"},{"location":"#webapp","text":"at some point a webapp will be implemented to show layout status and start cripts. Some details are provided in Webserver.md","title":"webapp"},{"location":"#reference","text":"LocoNet personal edition [Pdf] A better formatted version of the above DCC wiki on the electrical side of LocoNet JMRI's constant defintions that include the \u00dchlenbrock extended opcodes","title":"reference"},{"location":"Webserver/","text":"webserver The idea is that it should be easy to create a webserver that serves realtime information on the layout status. With the use of the Scrollkeeper class we already have everything we need to keep the status up to date, so we just have to add some frontend. a web frontend The frontend needs to be able to serve a few static pages but also to provide status info. Status info can be provided easily by implementing a small REST API for example but what we really want is to push the data as soon as something in the lsyout status is different. Fortunately all these requirements can be met with fastapi that not just enables use to create REST functionality in a really simple way, but also allows serving static pages and more importantly, can implement web sockets. flowchart LR Interface --> Scrollkeeper --> fastapi : app --> uvicorn --> webbrowser experiments A tiny sample implementation is a starting point for further enhancements. It serves a webpage that will open a websocket. This websocket periodically sends a list of known sensor ids.","title":"webserver"},{"location":"Webserver/#webserver","text":"The idea is that it should be easy to create a webserver that serves realtime information on the layout status. With the use of the Scrollkeeper class we already have everything we need to keep the status up to date, so we just have to add some frontend.","title":"webserver"},{"location":"Webserver/#a-web-frontend","text":"The frontend needs to be able to serve a few static pages but also to provide status info. Status info can be provided easily by implementing a small REST API for example but what we really want is to push the data as soon as something in the lsyout status is different. Fortunately all these requirements can be met with fastapi that not just enables use to create REST functionality in a really simple way, but also allows serving static pages and more importantly, can implement web sockets. flowchart LR Interface --> Scrollkeeper --> fastapi : app --> uvicorn --> webbrowser","title":"a web frontend"},{"location":"Webserver/#experiments","text":"A tiny sample implementation is a starting point for further enhancements. It serves a webpage that will open a websocket. This websocket periodically sends a list of known sensor ids.","title":"experiments"},{"location":"capture_and_replay/","text":"capture and replay The Interface class can write every incoming and outgoing message as raw bytes to a file. It can also read from this file instead of from a serial port. Not only is this a great help during development because it spares us the effort of running trains again and again just to see activity on the LocoNet bus, it can also help for the same reason when developing scripts that use the library. options The monitoring program has options to enable capturing or replay Capture: python -m pylnlib -c -f capturefile Replay: python -m pylnlib -r -f capturefile Output messages are captured as well but during replay no output is generated. Instead, any captured output is shown as is. This means that we can replay without being connected to a command station. timestamps When capturing you also specify the -t option: python -m pylnlib -c -t -f capturefile This will write a timestamp before every message that is written to the capture file. During replay this timestamp is used to replay the messages in the exact same tempo as they were recorded. The timestamps are written to the capture file as an unused but valid, 6-byte LocoNet message with opcode 0xc0. A corresponding CaptureTimeStamp class is defined to represent this. The 6 bytes of the message are, C0 hh mm ss ff checksum. Where hh, mm and ss represent the hour, minutes and seconds espectively, and ff the fraction of the seconds in hundredths. Without timestamps present, replay will process captured messages as fast as possible.","title":"capture and replay"},{"location":"capture_and_replay/#capture-and-replay","text":"The Interface class can write every incoming and outgoing message as raw bytes to a file. It can also read from this file instead of from a serial port. Not only is this a great help during development because it spares us the effort of running trains again and again just to see activity on the LocoNet bus, it can also help for the same reason when developing scripts that use the library.","title":"capture and replay"},{"location":"capture_and_replay/#options","text":"The monitoring program has options to enable capturing or replay Capture: python -m pylnlib -c -f capturefile Replay: python -m pylnlib -r -f capturefile Output messages are captured as well but during replay no output is generated. Instead, any captured output is shown as is. This means that we can replay without being connected to a command station.","title":"options"},{"location":"capture_and_replay/#timestamps","text":"When capturing you also specify the -t option: python -m pylnlib -c -t -f capturefile This will write a timestamp before every message that is written to the capture file. During replay this timestamp is used to replay the messages in the exact same tempo as they were recorded. The timestamps are written to the capture file as an unused but valid, 6-byte LocoNet message with opcode 0xc0. A corresponding CaptureTimeStamp class is defined to represent this. The 6 bytes of the message are, C0 hh mm ss ff checksum. Where hh, mm and ss represent the hour, minutes and seconds espectively, and ff the fraction of the seconds in hundredths. Without timestamps present, replay will process captured messages as fast as possible.","title":"timestamps"},{"location":"apidoc/pylnlib.Interface/","text":"module pylnlib . Interface </> Classes Interface \u2014 Handles thread safe sending and receiving LocoNet messages on a serial interface. </> Functions timeDiff ( a , b ) \u2014 return the total number of seconds between a and b. </> class pylnlib.Interface . Interface ( port , baud=57600 , fast=False , dummy=False ) </> Handles thread safe sending and receiving LocoNet messages on a serial interface. It will gracefully exit if it receives a SIGINT or SIGTERM signal. function pylnlib.Interface . timeDiff ( a , b ) </> return the total number of seconds between a and b. b MUST be later than a, so the difference between a = 23:55:49 and b = 00:05:49 will be correctly reported as 10 minutes.","title":"pylnlib.Interface"},{"location":"apidoc/pylnlib.Interface/#pylnlibinterface","text":"</> Classes Interface \u2014 Handles thread safe sending and receiving LocoNet messages on a serial interface. </> Functions timeDiff ( a , b ) \u2014 return the total number of seconds between a and b. </> class","title":"pylnlib.Interface"},{"location":"apidoc/pylnlib.Interface/#pylnlibinterfaceinterface","text":"</> Handles thread safe sending and receiving LocoNet messages on a serial interface. It will gracefully exit if it receives a SIGINT or SIGTERM signal. function","title":"pylnlib.Interface.Interface"},{"location":"apidoc/pylnlib.Interface/#pylnlibinterfacetimediff","text":"</> return the total number of seconds between a and b. b MUST be later than a, so the difference between a = 23:55:49 and b = 00:05:49 will be correctly reported as 10 minutes.","title":"pylnlib.Interface.timeDiff"},{"location":"apidoc/pylnlib.Message/","text":"module pylnlib . Message </> Classes Message \u2014 represents a LocoNet message. </> Unknown \u2014 An Unknown message simply holds the data bytes. </> PowerOn \u2014 A PowerOn message represents a global track power on message. </> PowerOff \u2014 A PowerOff message represents a global track power off message. </> FunctionGroup1 \u2014 A FunctionGroup1 message represents a slot function status change. </> FunctionGroupSound \u2014 A FunctionGroupSound message represents a slot function status change. </> FunctionGroup2 \u2014 A FunctionGroup2 message represents a slot function status change. </> FunctionGroup3 \u2014 A FunctionGroup3 message represents a slot function status change. </> RequestSwitchFunction \u2014 A RequestSwitchFunction message represents a request for a switch status change. </> SwitchState \u2014 represents a LocoNet message. </> RequestSwitchState \u2014 represents a LocoNet message. </> SensorState \u2014 represents a LocoNet message. </> LongAcknowledge \u2014 represents a LocoNet message. </> RequestSlotData \u2014 represents a LocoNet message. </> SlotDataReturn \u2014 represents a LocoNet message. </> WriteSlotData \u2014 represents a LocoNet message. </> SlotSpeed \u2014 represents a LocoNet message. </> RequestLocAddress \u2014 represents a LocoNet message. </> MoveSlots \u2014 represents a LocoNet message. </> CaptureTimeStamp \u2014 represents a LocoNet message. </> class pylnlib.Message . Message ( data ) </> represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . Unknown ( data ) </> Bases pylnlib.Message.Message An Unknown message simply holds the data bytes. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . PowerOn ( data ) </> Bases pylnlib.Message.Message A PowerOn message represents a global track power on message. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . PowerOff ( data ) </> Bases pylnlib.Message.Message A PowerOff message represents a global track power off message. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . FunctionGroup1 ( data=None , slot=None , dir=None , f0=None , f1=None , f2=None , f3=None , f4=None ) </> Bases pylnlib.Message.Message A FunctionGroup1 message represents a slot function status change. It holds the status for the direction and functions f0 - f4. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . FunctionGroupSound ( data=None , slot=None , f5=None , f6=None , f7=None , f8=None ) </> Bases pylnlib.Message.Message A FunctionGroupSound message represents a slot function status change. It holds the status for functions f5 - f8. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . FunctionGroup2 ( data ) </> Bases pylnlib.Message.Message A FunctionGroup2 message represents a slot function status change. It holds the status for functions f9 - f12. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . FunctionGroup3 ( data ) </> Bases pylnlib.Message.Message A FunctionGroup3 message represents a slot function status change. Depending on the fiegroup, tt holds the status for functions f13 - f19, f21 - f27 or f12 + f20 +f28. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . RequestSwitchFunction ( data , thrown=None , engage=None ) </> Bases pylnlib.Message.Message A RequestSwitchFunction message represents a request for a switch status change. It holds the info on whether the switch should be closed or thrown, as well as whether the switch motor should be engaged. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . SwitchState ( data ) </> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . RequestSwitchState ( id ) </> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . SensorState ( id ) </> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . LongAcknowledge ( data ) </> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . RequestSlotData ( slot ) </> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . SlotDataReturn ( data ) </> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . WriteSlotData ( slot ) </> Bases pylnlib.Message.SlotDataReturn pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . SlotSpeed ( data=None , slot=None , speed=None ) </> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . RequestLocAddress ( address ) </> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . MoveSlots ( data=None , src=None , dst=None ) </> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class pylnlib.Message . CaptureTimeStamp ( t ) </> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method hexdata ( ) </> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method updateChecksum ( ) </> Calculate the checksum of the data and store it in the last byte. staticmethod length ( opcode , nextbyte ) </> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod from_data ( data ) </> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod checksum ( msg ) </> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod sensoraddress ( d0 , d1 ) </> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod switchaddress ( d0 , d1 ) </> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod slotaddress ( d0 , d1 ) </> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70).","title":"pylnlib.Message"},{"location":"apidoc/pylnlib.Message/#pylnlibmessage","text":"</> Classes Message \u2014 represents a LocoNet message. </> Unknown \u2014 An Unknown message simply holds the data bytes. </> PowerOn \u2014 A PowerOn message represents a global track power on message. </> PowerOff \u2014 A PowerOff message represents a global track power off message. </> FunctionGroup1 \u2014 A FunctionGroup1 message represents a slot function status change. </> FunctionGroupSound \u2014 A FunctionGroupSound message represents a slot function status change. </> FunctionGroup2 \u2014 A FunctionGroup2 message represents a slot function status change. </> FunctionGroup3 \u2014 A FunctionGroup3 message represents a slot function status change. </> RequestSwitchFunction \u2014 A RequestSwitchFunction message represents a request for a switch status change. </> SwitchState \u2014 represents a LocoNet message. </> RequestSwitchState \u2014 represents a LocoNet message. </> SensorState \u2014 represents a LocoNet message. </> LongAcknowledge \u2014 represents a LocoNet message. </> RequestSlotData \u2014 represents a LocoNet message. </> SlotDataReturn \u2014 represents a LocoNet message. </> WriteSlotData \u2014 represents a LocoNet message. </> SlotSpeed \u2014 represents a LocoNet message. </> RequestLocAddress \u2014 represents a LocoNet message. </> MoveSlots \u2014 represents a LocoNet message. </> CaptureTimeStamp \u2014 represents a LocoNet message. </> class","title":"pylnlib.Message"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessage","text":"</> represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.Message"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessageunknown","text":"</> Bases pylnlib.Message.Message An Unknown message simply holds the data bytes. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.Unknown"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_1","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_1","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_1","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_1","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_1","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_1","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_1","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_1","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagepoweron","text":"</> Bases pylnlib.Message.Message A PowerOn message represents a global track power on message. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.PowerOn"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_2","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_2","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_2","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_2","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_2","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_2","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_2","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_2","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagepoweroff","text":"</> Bases pylnlib.Message.Message A PowerOff message represents a global track power off message. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.PowerOff"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_3","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_3","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_3","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_3","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_3","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_3","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_3","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_3","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagefunctiongroup1","text":"</> Bases pylnlib.Message.Message A FunctionGroup1 message represents a slot function status change. It holds the status for the direction and functions f0 - f4. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.FunctionGroup1"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_4","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_4","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_4","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_4","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_4","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_4","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_4","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_4","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagefunctiongroupsound","text":"</> Bases pylnlib.Message.Message A FunctionGroupSound message represents a slot function status change. It holds the status for functions f5 - f8. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.FunctionGroupSound"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_5","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_5","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_5","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_5","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_5","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_5","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_5","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_5","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagefunctiongroup2","text":"</> Bases pylnlib.Message.Message A FunctionGroup2 message represents a slot function status change. It holds the status for functions f9 - f12. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.FunctionGroup2"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_6","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_6","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_6","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_6","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_6","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_6","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_6","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_6","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagefunctiongroup3","text":"</> Bases pylnlib.Message.Message A FunctionGroup3 message represents a slot function status change. Depending on the fiegroup, tt holds the status for functions f13 - f19, f21 - f27 or f12 + f20 +f28. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.FunctionGroup3"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_7","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_7","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_7","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_7","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_7","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_7","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_7","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_7","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagerequestswitchfunction","text":"</> Bases pylnlib.Message.Message A RequestSwitchFunction message represents a request for a switch status change. It holds the info on whether the switch should be closed or thrown, as well as whether the switch motor should be engaged. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.RequestSwitchFunction"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_8","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_8","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_8","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_8","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_8","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_8","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_8","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_8","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessageswitchstate","text":"</> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.SwitchState"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_9","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_9","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_9","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_9","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_9","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_9","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_9","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_9","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagerequestswitchstate","text":"</> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.RequestSwitchState"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_10","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_10","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_10","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_10","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_10","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_10","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_10","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_10","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagesensorstate","text":"</> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.SensorState"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_11","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_11","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_11","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_11","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_11","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_11","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_11","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_11","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagelongacknowledge","text":"</> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.LongAcknowledge"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_12","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_12","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_12","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_12","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_12","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_12","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_12","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_12","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagerequestslotdata","text":"</> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.RequestSlotData"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_13","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_13","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_13","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_13","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_13","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_13","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_13","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_13","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessageslotdatareturn","text":"</> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.SlotDataReturn"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_14","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_14","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_14","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_14","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_14","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_14","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_14","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_14","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagewriteslotdata","text":"</> Bases pylnlib.Message.SlotDataReturn pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.WriteSlotData"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_15","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_15","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_15","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_15","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_15","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_15","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_15","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_15","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessageslotspeed","text":"</> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.SlotSpeed"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_16","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_16","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_16","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_16","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_16","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_16","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_16","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_16","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagerequestlocaddress","text":"</> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.RequestLocAddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_17","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_17","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_17","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_17","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_17","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_17","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_17","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_17","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemoveslots","text":"</> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.MoveSlots"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_18","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_18","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_18","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_18","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_18","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_18","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_18","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_18","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). class","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagecapturetimestamp","text":"</> Bases pylnlib.Message.Message represents a LocoNet message. several subclasses are provided to implemented actual messages. Methods checksum ( msg ) \u2014 Calculate the checksum over the data of a message. </> from_data ( data ) \u2014 A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. </> hexdata ( ) \u2014 Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. </> length ( opcode , nextbyte ) \u2014 Determine the length of a LocoNet message based on its opcode and next byte. </> sensoraddress ( d0 , d1 ) \u2014 Return a sensor address from the data. </> slotaddress ( d0 , d1 ) \u2014 Return a slot address from the data. </> switchaddress ( d0 , d1 ) \u2014 Return a switch address from the data. </> updateChecksum ( ) \u2014 Calculate the checksum of the data and store it in the last byte. </> method","title":"pylnlib.Message.CaptureTimeStamp"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagehexdata_19","text":"</> Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. method","title":"pylnlib.Message.Message.hexdata"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageupdatechecksum_19","text":"</> Calculate the checksum of the data and store it in the last byte. staticmethod","title":"pylnlib.Message.Message.updateChecksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagelength_19","text":"</> Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. staticmethod","title":"pylnlib.Message.Message.length"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagefrom_data_19","text":"</> A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. staticmethod","title":"pylnlib.Message.Message.from_data"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagechecksum_19","text":"</> Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. staticmethod","title":"pylnlib.Message.Message.checksum"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessagesensoraddress_19","text":"</> Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.sensoraddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageswitchaddress_19","text":"</> Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). staticmethod","title":"pylnlib.Message.Message.switchaddress"},{"location":"apidoc/pylnlib.Message/#pylnlibmessagemessageslotaddress_19","text":"</> Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70).","title":"pylnlib.Message.Message.slotaddress"},{"location":"apidoc/pylnlib.Scrollkeeper/","text":"module pylnlib . Scrollkeeper </> Classes Scrollkeeper \u2014 A Scrollkeeper instance keeps track of the state of slots, sensors and switches. </> class pylnlib.Scrollkeeper . Scrollkeeper ( interface , slottrace=False ) </> A Scrollkeeper instance keeps track of the state of slots, sensors and switches. A Scrollkeeper instance uses information sent to its messageListener method to keep track of changes to slots, sensors and switches. If it receives messages for which it does not have a Slot, Sensor or Switch instance, it will send requests to get this information. Parameters interface (Interface) \u2014 used to send a message if no information on a particular item is present. slottrace (bool, optional) \u2014 log every internal update to the console. Defaults to False. Methods getLocoSlot ( address ) (Slot) \u2014 Return the slot id associated with the loc address. </> getSensorState ( id ) \u2014 Return the state of the sensor. </> getSwitchState ( id ) \u2014 Return the state of the switch. </> messageListener ( msg ) \u2014 Handles incoming messages and updates internal state. </> sendMessage ( message ) \u2014 place a message in the output queue of the interface. </> updateSensor ( address , level ) \u2014 Update the attributes of a sensor. </> updateSlot ( id , **kwargs ) \u2014 Update attributes of a slot. </> updateSwitch ( address , thrown , engage ) \u2014 update the status of a switch. </> method messageListener ( msg ) </> Handles incoming messages and updates internal state. If information refering an unknown slot comes in, it will issue a slot status request. Parameters msg (Message) \u2014 An instance of a (subclass of a) Message. method updateSlot ( id , **kwargs ) </> Update attributes of a slot. The method is thread safe. Parameters id (int) \u2014 The slot id. method updateSensor ( address , level=None ) </> Update the attributes of a sensor. The method is thread safe. Parameters address (int) \u2014 The address of the sensor. This is zero based. level (bool, optional) \u2014 Either True (on) or False (off). Defaults to None. method updateSwitch ( address , thrown=None , engage=None ) </> update the status of a switch. The method is thread safe. Parameters address (int) \u2014 The address of the switch. This is zero based. thrown (bool, optional) \u2014 direction of the switch. True (thrown, aka Open) or False (closed). Defaults to None. engage (bool, optional) \u2014 whether the servo is engaged. Defaults to None. method getLocoSlot ( address ) </> Return the slot id associated with the loc address. If there is no slot known for this loc, request slot data. Parameters address (int) \u2014 loc address Raises ValueError \u2014 if no slot data is available for this loc address Returns (Slot) The Slot instance associated with this loc address. method getSwitchState ( id ) </> Return the state of the switch. if the switch is unknown, request the status. method getSensorState ( id ) </> Return the state of the sensor. if the sensor is unknown, request the status. method sendMessage ( message ) </> place a message in the output queue of the interface.","title":"pylnlib.Scrollkeeper"},{"location":"apidoc/pylnlib.Scrollkeeper/#pylnlibscrollkeeper","text":"</> Classes Scrollkeeper \u2014 A Scrollkeeper instance keeps track of the state of slots, sensors and switches. </> class","title":"pylnlib.Scrollkeeper"},{"location":"apidoc/pylnlib.Scrollkeeper/#pylnlibscrollkeeperscrollkeeper","text":"</> A Scrollkeeper instance keeps track of the state of slots, sensors and switches. A Scrollkeeper instance uses information sent to its messageListener method to keep track of changes to slots, sensors and switches. If it receives messages for which it does not have a Slot, Sensor or Switch instance, it will send requests to get this information. Parameters interface (Interface) \u2014 used to send a message if no information on a particular item is present. slottrace (bool, optional) \u2014 log every internal update to the console. Defaults to False. Methods getLocoSlot ( address ) (Slot) \u2014 Return the slot id associated with the loc address. </> getSensorState ( id ) \u2014 Return the state of the sensor. </> getSwitchState ( id ) \u2014 Return the state of the switch. </> messageListener ( msg ) \u2014 Handles incoming messages and updates internal state. </> sendMessage ( message ) \u2014 place a message in the output queue of the interface. </> updateSensor ( address , level ) \u2014 Update the attributes of a sensor. </> updateSlot ( id , **kwargs ) \u2014 Update attributes of a slot. </> updateSwitch ( address , thrown , engage ) \u2014 update the status of a switch. </> method","title":"pylnlib.Scrollkeeper.Scrollkeeper"},{"location":"apidoc/pylnlib.Scrollkeeper/#pylnlibscrollkeeperscrollkeepermessagelistener","text":"</> Handles incoming messages and updates internal state. If information refering an unknown slot comes in, it will issue a slot status request. Parameters msg (Message) \u2014 An instance of a (subclass of a) Message. method","title":"pylnlib.Scrollkeeper.Scrollkeeper.messageListener"},{"location":"apidoc/pylnlib.Scrollkeeper/#pylnlibscrollkeeperscrollkeeperupdateslot","text":"</> Update attributes of a slot. The method is thread safe. Parameters id (int) \u2014 The slot id. method","title":"pylnlib.Scrollkeeper.Scrollkeeper.updateSlot"},{"location":"apidoc/pylnlib.Scrollkeeper/#pylnlibscrollkeeperscrollkeeperupdatesensor","text":"</> Update the attributes of a sensor. The method is thread safe. Parameters address (int) \u2014 The address of the sensor. This is zero based. level (bool, optional) \u2014 Either True (on) or False (off). Defaults to None. method","title":"pylnlib.Scrollkeeper.Scrollkeeper.updateSensor"},{"location":"apidoc/pylnlib.Scrollkeeper/#pylnlibscrollkeeperscrollkeeperupdateswitch","text":"</> update the status of a switch. The method is thread safe. Parameters address (int) \u2014 The address of the switch. This is zero based. thrown (bool, optional) \u2014 direction of the switch. True (thrown, aka Open) or False (closed). Defaults to None. engage (bool, optional) \u2014 whether the servo is engaged. Defaults to None. method","title":"pylnlib.Scrollkeeper.Scrollkeeper.updateSwitch"},{"location":"apidoc/pylnlib.Scrollkeeper/#pylnlibscrollkeeperscrollkeepergetlocoslot","text":"</> Return the slot id associated with the loc address. If there is no slot known for this loc, request slot data. Parameters address (int) \u2014 loc address Raises ValueError \u2014 if no slot data is available for this loc address Returns (Slot) The Slot instance associated with this loc address. method","title":"pylnlib.Scrollkeeper.Scrollkeeper.getLocoSlot"},{"location":"apidoc/pylnlib.Scrollkeeper/#pylnlibscrollkeeperscrollkeepergetswitchstate","text":"</> Return the state of the switch. if the switch is unknown, request the status. method","title":"pylnlib.Scrollkeeper.Scrollkeeper.getSwitchState"},{"location":"apidoc/pylnlib.Scrollkeeper/#pylnlibscrollkeeperscrollkeepergetsensorstate","text":"</> Return the state of the sensor. if the sensor is unknown, request the status. method","title":"pylnlib.Scrollkeeper.Scrollkeeper.getSensorState"},{"location":"apidoc/pylnlib.Scrollkeeper/#pylnlibscrollkeeperscrollkeepersendmessage","text":"</> place a message in the output queue of the interface.","title":"pylnlib.Scrollkeeper.Scrollkeeper.sendMessage"},{"location":"apidoc/pylnlib.Throttle/","text":"module pylnlib . Throttle </> Classes Throttle \u2014 A class to control a single locomotive. </> class pylnlib.Throttle . Throttle ( scrollkeeper , locaddress ) </> A class to control a single locomotive. Parameters scrollkeeper (Scrollkeeper) \u2014 used to send messages and retrieve slot information locaddress (int) \u2014 the address of the locomotive Methods forward ( speed ) \u2014 Changes the speed of a locomotive to forward and a given value. </> lights ( on , duration ) \u2014 Turn directional lights on or off. </> reverse ( speed ) \u2014 Changes the speed of a locomotive to reverse and a given value. </> sound ( on , duration ) \u2014 Turn sound on or off. </> whistle ( on , duration ) \u2014 Sound the whistle. </> method forward ( speed=0.0 ) </> Changes the speed of a locomotive to forward and a given value. Parameters speed (float, optional) \u2014 speed is a float in the range [0.0, 1.0], setting it to zero will initiate an inertial stop. Defaults to 0.0. Two LocoNet messages may be generated: Only if the direction is changed: a LocoNet direction message is generated for the slot that controls this loco. Only if the speed is changed: a LocoNet speed message is generated for the slot that controls this loco. method reverse ( speed=0.0 ) </> Changes the speed of a locomotive to reverse and a given value. Parameters speed (float, optional) \u2014 speed is a float in the range [0.0, 1.0], setting it to zero will initiate an inertial stop. Defaults to 0.0. Two LocoNet messages may be generated: Only if the direction is changed, a LocoNet direction message is generated for the slot that controls this loco. Only if the speed is changed, a LocoNet speed message is generated for the slot that controls this loco. method lights ( on=True , duration=0 ) </> Turn directional lights on or off. Parameters on (bool, optional) \u2014 new state of the directional lights. Defaults to True. duration (int, optional) \u2014 if larger than zero will revert the lights to the previous state after duration seconds. Defaults to 0. method sound ( on=True , duration=0 ) </> Turn sound on or off. Parameters on (bool, optional) \u2014 new state of the sound. Defaults to True. duration (int, optional) \u2014 if larger than zero will revert the sound to the previous state after duration seconds. Defaults to 0. Returns None method whistle ( on=True , duration=0.5 ) </> Sound the whistle. A loc decoder will typically use a short whistle sound that is silent after a short while, but it still needs to be turned off explicitely by the throttle, therefore the function defaults to 0.5 seconds. Parameters on (bool, optional) \u2014 new state of the whistle. Defaults to True. duration (float, optional) \u2014 if larger than zero will revert the whistle to the previous state after duration seconds. Defaults to 0.5.","title":"pylnlib.Throttle"},{"location":"apidoc/pylnlib.Throttle/#pylnlibthrottle","text":"</> Classes Throttle \u2014 A class to control a single locomotive. </> class","title":"pylnlib.Throttle"},{"location":"apidoc/pylnlib.Throttle/#pylnlibthrottlethrottle","text":"</> A class to control a single locomotive. Parameters scrollkeeper (Scrollkeeper) \u2014 used to send messages and retrieve slot information locaddress (int) \u2014 the address of the locomotive Methods forward ( speed ) \u2014 Changes the speed of a locomotive to forward and a given value. </> lights ( on , duration ) \u2014 Turn directional lights on or off. </> reverse ( speed ) \u2014 Changes the speed of a locomotive to reverse and a given value. </> sound ( on , duration ) \u2014 Turn sound on or off. </> whistle ( on , duration ) \u2014 Sound the whistle. </> method","title":"pylnlib.Throttle.Throttle"},{"location":"apidoc/pylnlib.Throttle/#pylnlibthrottlethrottleforward","text":"</> Changes the speed of a locomotive to forward and a given value. Parameters speed (float, optional) \u2014 speed is a float in the range [0.0, 1.0], setting it to zero will initiate an inertial stop. Defaults to 0.0. Two LocoNet messages may be generated: Only if the direction is changed: a LocoNet direction message is generated for the slot that controls this loco. Only if the speed is changed: a LocoNet speed message is generated for the slot that controls this loco. method","title":"pylnlib.Throttle.Throttle.forward"},{"location":"apidoc/pylnlib.Throttle/#pylnlibthrottlethrottlereverse","text":"</> Changes the speed of a locomotive to reverse and a given value. Parameters speed (float, optional) \u2014 speed is a float in the range [0.0, 1.0], setting it to zero will initiate an inertial stop. Defaults to 0.0. Two LocoNet messages may be generated: Only if the direction is changed, a LocoNet direction message is generated for the slot that controls this loco. Only if the speed is changed, a LocoNet speed message is generated for the slot that controls this loco. method","title":"pylnlib.Throttle.Throttle.reverse"},{"location":"apidoc/pylnlib.Throttle/#pylnlibthrottlethrottlelights","text":"</> Turn directional lights on or off. Parameters on (bool, optional) \u2014 new state of the directional lights. Defaults to True. duration (int, optional) \u2014 if larger than zero will revert the lights to the previous state after duration seconds. Defaults to 0. method","title":"pylnlib.Throttle.Throttle.lights"},{"location":"apidoc/pylnlib.Throttle/#pylnlibthrottlethrottlesound","text":"</> Turn sound on or off. Parameters on (bool, optional) \u2014 new state of the sound. Defaults to True. duration (int, optional) \u2014 if larger than zero will revert the sound to the previous state after duration seconds. Defaults to 0. Returns None method","title":"pylnlib.Throttle.Throttle.sound"},{"location":"apidoc/pylnlib.Throttle/#pylnlibthrottlethrottlewhistle","text":"</> Sound the whistle. A loc decoder will typically use a short whistle sound that is silent after a short while, but it still needs to be turned off explicitely by the throttle, therefore the function defaults to 0.5 seconds. Parameters on (bool, optional) \u2014 new state of the whistle. Defaults to True. duration (float, optional) \u2014 if larger than zero will revert the whistle to the previous state after duration seconds. Defaults to 0.5.","title":"pylnlib.Throttle.Throttle.whistle"},{"location":"apidoc/pylnlib.Utils/","text":"module pylnlib . Utils </> Classes Args \u2014 Common command line argument parsing. </> Functions createInterface ( args ) \u2014 create an Interface object, possibly pointing to a file with previously captured input. </> createScrollkeeper ( interface , args ) (Scrollkeeper) \u2014 Create a Scrollkeeper instance that receives and sends messages via interface. </> dumper ( handle , timestamp ) \u2014 return a function that writes raw message data to a file. </> logger ( msg ) \u2014 Write a message with a timestamp to stderr. </> reporter ( scrollkeeper , interval ) \u2014 return a function that prints the contents of a Scrollkeeper instance at regular intervals. </> class pylnlib.Utils . Args ( ) </> Common command line argument parsing. function pylnlib.Utils . logger ( msg ) </> Write a message with a timestamp to stderr. function pylnlib.Utils . dumper ( handle , timestamp=False ) </> return a function that writes raw message data to a file. If timestamp is true, it will prefix each message with a CaptureTimeStamp function pylnlib.Utils . reporter ( scrollkeeper , interval=30 ) </> return a function that prints the contents of a Scrollkeeper instance at regular intervals. function pylnlib.Utils . createInterface ( args ) </> create an Interface object, possibly pointing to a file with previously captured input. function pylnlib.Utils . createScrollkeeper ( interface , args ) </> Create a Scrollkeeper instance that receives and sends messages via interface. Parameters interface (Interface) \u2014 The Interface object that the Scrollkeeper will register a receiver_handler with args (Namespace) \u2014 A Namespace (as returned by Argparser.argse_parse() ). Should have slottrace and dummy attributes. Returns (Scrollkeeper) a Scrollkeeper instance. See Also Args","title":"pylnlib.Utils"},{"location":"apidoc/pylnlib.Utils/#pylnlibutils","text":"</> Classes Args \u2014 Common command line argument parsing. </> Functions createInterface ( args ) \u2014 create an Interface object, possibly pointing to a file with previously captured input. </> createScrollkeeper ( interface , args ) (Scrollkeeper) \u2014 Create a Scrollkeeper instance that receives and sends messages via interface. </> dumper ( handle , timestamp ) \u2014 return a function that writes raw message data to a file. </> logger ( msg ) \u2014 Write a message with a timestamp to stderr. </> reporter ( scrollkeeper , interval ) \u2014 return a function that prints the contents of a Scrollkeeper instance at regular intervals. </> class","title":"pylnlib.Utils"},{"location":"apidoc/pylnlib.Utils/#pylnlibutilsargs","text":"</> Common command line argument parsing. function","title":"pylnlib.Utils.Args"},{"location":"apidoc/pylnlib.Utils/#pylnlibutilslogger","text":"</> Write a message with a timestamp to stderr. function","title":"pylnlib.Utils.logger"},{"location":"apidoc/pylnlib.Utils/#pylnlibutilsdumper","text":"</> return a function that writes raw message data to a file. If timestamp is true, it will prefix each message with a CaptureTimeStamp function","title":"pylnlib.Utils.dumper"},{"location":"apidoc/pylnlib.Utils/#pylnlibutilsreporter","text":"</> return a function that prints the contents of a Scrollkeeper instance at regular intervals. function","title":"pylnlib.Utils.reporter"},{"location":"apidoc/pylnlib.Utils/#pylnlibutilscreateinterface","text":"</> create an Interface object, possibly pointing to a file with previously captured input. function","title":"pylnlib.Utils.createInterface"},{"location":"apidoc/pylnlib.Utils/#pylnlibutilscreatescrollkeeper","text":"</> Create a Scrollkeeper instance that receives and sends messages via interface. Parameters interface (Interface) \u2014 The Interface object that the Scrollkeeper will register a receiver_handler with args (Namespace) \u2014 A Namespace (as returned by Argparser.argse_parse() ). Should have slottrace and dummy attributes. Returns (Scrollkeeper) a Scrollkeeper instance. See Also Args","title":"pylnlib.Utils.createScrollkeeper"},{"location":"apidoc/pylnlib/","text":"package pylnlib </> This package can be invoked as a module. Example python -m pylnlib If invoked this way, it will start listening for data on a serial interface and will report any incoming messages. Incoming messages related to unknown slots, switches or sensors will trigger outgoing status request messages. It can both capture and replay messages. For more info run it with the -- help option python -m pylnlib --help","title":"pylnlib"},{"location":"apidoc/pylnlib/#pylnlib","text":"</> This package can be invoked as a module. Example python -m pylnlib If invoked this way, it will start listening for data on a serial interface and will report any incoming messages. Incoming messages related to unknown slots, switches or sensors will trigger outgoing status request messages. It can both capture and replay messages. For more info run it with the -- help option python -m pylnlib --help","title":"pylnlib"},{"location":"apidoc/source/pylnlib.Interface/","text":"SOURCE CODE pylnlib. Interface DOCS # pylnlib : a package to communicate with a model railroad controller using the LocoNet\u00ae protocol # # (c) 2022 Michel Anders (varkenvarken) # # License: GPL 3, see file LICENSE # # Version: 20220709155819 import signal import sys import threading from datetime import datetime from queue import Queue from time import sleep import serial from .Message import CaptureTimeStamp , Message class Interface : DOCS \"\"\" Handles thread safe sending and receiving LocoNet messages on a serial interface. It will gracefully exit if it receives a SIGINT or SIGTERM signal. \"\"\" def __init__ ( self , port : str , baud : int = 57600 , fast : bool = False , dummy : bool = False ): \"\"\" Creates an Interface instance. Args: port (str): seriall port, on Linux typically something like /dev/ttyACM0 baud (int, optional): the baudrate. Defaults to 57600. fast (bool, optional): if false it uses timestamp message in the input data to replay a realistic speed. Defaults to False. dummy (bool, optional): if true it will not write anyhting on the serial port. Defaults to False. See Also: [Capture and replay](capture_and_replay) \"\"\" self . time = None self . fast = fast self . dummy = dummy signal . signal ( signal . SIGTERM , self . on_interrupt ) signal . signal ( signal . SIGINT , self . on_interrupt ) self . exit = False self . capture_finished = False self . inputThread = threading . Thread ( name = \"receiver\" , target = self . receiver_thread ) self . inputThread . setDaemon ( True ) self . receiver_handler = [] self . rd_event = threading . Event () self . inputqueue = Queue () self . outputThread = threading . Thread ( name = \"sender\" , target = self . sender_thread ) self . outputThread . setDaemon ( True ) self . outputqueue = Queue () self . input = \"com\" if type ( port ) == str : if not dummy : try : # 8 bits, 1 stop bit, 1 start bit self . com = serial . Serial ( port = port , baudrate = baud , stopbits = serial . STOPBITS_ONE , bytesize = serial . EIGHTBITS , timeout = None , ) except serial . SerialException as e : exit ( e ) else : self . input = \"file\" self . com = port def on_interrupt ( self , signum , frame ): self . exit = True def on_receive ( self , msg ): if self . receiver_handler != None : for handler in self . receiver_handler : handler ( msg ) def processTimeStamp ( self , msg ): if not self . fast and self . time is not None : sleep ( timeDiff ( self . time , msg . time )) self . time = msg . time def run ( self , delay = 0 ): self . time = None self . inputThread . start () self . outputThread . start () # main loop that pulls messages from msg_queue while not self . exit : if self . rd_event . wait ( 1 ): self . rd_event . clear () while not self . inputqueue . empty (): if delay > 0 : sleep ( delay ) msg = self . inputqueue . get () if isinstance ( msg , CaptureTimeStamp ): self . processTimeStamp ( msg ) else : self . on_receive ( msg ) self . inputThread . join () self . outputThread . join () self . com . close () print ( \"Done...\" , file = sys . stderr ) def run_in_background ( self , delay ): threading . Thread ( name = \"interface\" , target = self . run , daemon = True , args = ( delay ,) ) . start () def receiver_thread ( self ): while not self . exit : if self . dummy : sleep ( 0.1 ) elif self . input == \"com\" : n = self . com . inWaiting () if n > 1 : # all messages are at least 2 bytes data = self . com . read ( 2 ) length = Message . length ( data [ 0 ], data [ 1 ]) if length == 2 : msg = Message . from_data ( data ) else : data2 = self . com . read ( length - 2 ) # this is blocking, might want to change that msg = Message . from_data ( data + data2 ) self . inputqueue . put ( msg ) self . rd_event . set () else : sleep ( 0.1 ) elif not self . capture_finished : data = self . com . read ( 2 ) if len ( data ) == 0 : self . capture_finished = True elif len ( data ) < 2 : raise IOError ( \"captured stream ended prematurely\" ) else : length = Message . length ( data [ 0 ], data [ 1 ]) if length == 2 : msg = Message . from_data ( data ) else : data2 = self . com . read ( length - 2 ) if len ( data2 ) < length - 2 : raise IOError ( \"captured stream ended prematurely\" ) msg = Message . from_data ( data + data2 ) self . inputqueue . put ( msg ) self . rd_event . set () def sender_thread ( self ): while not self . exit : if not self . outputqueue . empty (): msg = self . outputqueue . get () if self . input == \"com\" and not self . dummy : self . com . write ( msg . data ) else : # on replay or dummy output we simply shunt back the output message self . inputqueue . put ( msg ) self . rd_event . set () sleep ( 0.25 ) def sendMessage ( self , msg ): self . outputqueue . put ( msg ) def timeDiff ( a , b ): DOCS \"\"\" return the total number of seconds between a and b. b MUST be later than a, so the difference between a = 23:55:49 and b = 00:05:49 will be correctly reported as 10 minutes. \"\"\" T = datetime . today () A = datetime . combine ( T , a ) B = datetime . combine ( T , b ) s = ( B - A ) . total_seconds () if s < 0 : s = 24 * 3600 - s return s","title":"pylnlib.Interface"},{"location":"apidoc/source/pylnlib.Message/","text":"SOURCE CODE pylnlib. Message DOCS # pylnlib : a package to communicate with a model railroad controller using the LocoNet\u00ae protocol # # (c) 2022 Michel Anders (varkenvarken) # # License: GPL 3, see file LICENSE # # Version: 20220709153032 # Based on LocoNet\u00ae Personal Use Edition 1.0 SPECIFICATION # Which is \u00a9 Digitrax Inc. # See also: https://www.digitrax.com/static/apps/cms/media/documents/loconet/loconetpersonaledition.pdf # See also: https://wiki.rocrail.net/doku.php?id=loconet:ln-pe-en from datetime import time class Message : DOCS \"\"\" represents a LocoNet message. several subclasses are provided to implemented actual messages. \"\"\" OPC_GPON = 0x83 OPC_GPOFF = 0x82 OPC_LOCO_SPD = 0xA0 OPC_LOCO_DIRF = 0xA1 OPC_LOCO_SND = 0xA2 OPC_LOCO_F2 = 0xA3 # not defined in locnet specs, but implemented nevertheless OPC_SW_REQ = 0xB0 OPC_SW_REP = 0xB1 # not implemented OPC_INPUT_REP = 0xB2 OPC_LONG_ACK = 0xB4 OPC_SLOT_STAT1 = 0xB5 # not implemented OPC_CONSIST_FUNC = 0xB6 # not implemented OPC_UNLINK_SLOTS = 0xB8 # not implemented OPC_LINK_SLOTS = 0xB9 # not implemented OPC_MOVE_SLOTS = 0xBA # not implemented OPC_RQ_SL_DATA = 0xBB OPC_SW_STATE = 0xBC OPC_SW_ACK = 0xBD # not implemented OPC_LOCO_ADR = 0xBF OPC_LOCO_F3 = 0xD4 # not defined in locnet specs, but implemented nevertheless (seen on Roco WLAN maus) OPC_SL_RD_DATA = 0xE7 OPC_WR_SL_DATA = 0xEF def __init__ ( self , data ): \"\"\" Initialize a message from a byte array. The 'opcode' (message type) is determined from byte 0, The length of the data (incl. the checksum) is determined by bits in the first byte and the second byte (if it is a variable byte message) The checksum is the last byte in the data. If the last byte in the data is 0, no check is done, so you can create a message from scratch and calculate the checksum later. If the length of the byte array does not match the encoded length, a ValueError is raised. If the calculated checksum doesn match the last byte of the byte array, a ValueError is raised (unless the last data byte is 0) \"\"\" self . opcode = data [ 0 ] self . length = Message . length ( data [ 0 ], data [ 1 ]) self . data = data self . checksum = data [ - 1 ] if len ( data ) != self . length : raise ValueError ( \"length mismatch\" ) if self . checksum and self . checksum != Message . checksum ( data [: - 1 ]): raise ValueError ( \"checksum error\" ) def hexdata ( self ): DOCS \"\"\" Return the message data as a list of numbers formatted as hexadecimals with 2 digits and without 0x prefix. \"\"\" return list ( f \" { v : 02x } \" for v in map ( int , self . data )) def __str__ ( self ): return f \" { self . __class__ . __name__ } (opcode= { hex ( self . opcode ) } , { self . length =} , data= { list ( map ( hex , map ( int , self . data ))) } )\" def updateChecksum ( self ): DOCS \"\"\" Calculate the checksum of the data and store it in the last byte. \"\"\" self . checksum = self . data [ - 1 ] = Message . checksum ( self . data [: - 1 ]) @staticmethod DOCS def length ( opcode , nextbyte ): \"\"\" Determine the length of a LocoNet message based on its opcode and next byte. The next byte holds the total number of bytes in the message if the opcode indicates this is a variable length message. The length is inclusive the opcode and the final checksum. \"\"\" d6d5 = ( opcode >> 5 ) & 3 if d6d5 == 0 : return 2 elif d6d5 == 1 : return 4 elif d6d5 == 2 : return 6 else : return int ( nextbyte ) @staticmethod DOCS def from_data ( data ): \"\"\" A factory method that returns a specific subclass of a Message based on the opcode, or an instance of Unknown. TODO: not all possible opcodes/message types are implemented yet. \"\"\" opcode = data [ 0 ] if opcode == 0x83 : return PowerOn ( data ) elif opcode == 0x82 : return PowerOff ( data ) elif opcode == Message . OPC_LOCO_SPD : return SlotSpeed ( data ) elif opcode == Message . OPC_LOCO_DIRF : return FunctionGroup1 ( data ) elif opcode == Message . OPC_LOCO_SND : return FunctionGroupSound ( data ) elif opcode == Message . OPC_LOCO_F2 : return FunctionGroup2 ( data ) elif opcode == 0xD4 : return FunctionGroup3 ( data ) elif opcode == 0xB0 : return RequestSwitchFunction ( data ) elif opcode == 0xB1 : return SwitchState ( data ) elif opcode == 0xB2 : return SensorState ( data ) elif opcode == 0xB4 : return LongAcknowledge ( data ) elif opcode == 0xBA : return MoveSlots ( data ) elif opcode == 0xBB : return RequestSlotData ( data ) elif opcode == 0xBC : return RequestSwitchState ( data ) elif opcode == 0xC0 : return CaptureTimeStamp ( data ) elif opcode == 0xBF : return RequestLocAddress ( data ) elif opcode == 0xE7 : return SlotDataReturn ( data ) elif opcode == 0xEF : return WriteSlotData ( data ) return Unknown ( data ) @staticmethod DOCS def checksum ( msg ): \"\"\" Calculate the checksum over the data of a message. The checksum is calculate over all data bytes except the last one (which will be the checksum). This method does NOT overwrite the checksum byte. \"\"\" chksum = 0 for c in msg : chksum = chksum ^ ( c ^ 0xFF ) return chksum @staticmethod DOCS def sensoraddress ( d0 , d1 ): \"\"\" Return a sensor address from the data. Sensors start from zero (but may typically displayed with an added offset of 1). \"\"\" return (( d0 & 0x7F ) << 1 ) | (( d1 & 0x0F ) << 8 ) | (( d1 >> 5 ) & 0x1 ) @staticmethod DOCS def switchaddress ( d0 , d1 ): \"\"\" Return a switch address from the data. Switches start from zero (but may typically displayed with an added offset of 1). \"\"\" return ( d0 & 0x7F ) | (( d1 & 0x0F ) << 7 ) @staticmethod DOCS def slotaddress ( d0 , d1 ): \"\"\" Return a slot address from the data. Slots start from zero (but slot 0 is special, as are several others >= 0x70). \"\"\" return ( d0 & 0x7F ) | (( d1 & 0x0F ) << 7 ) class Unknown ( Message ): DOCS \"\"\" An Unknown message simply holds the data bytes. \"\"\" pass class PowerOn ( Message ): DOCS \"\"\" A PowerOn message represents a global track power on message. \"\"\" pass class PowerOff ( Message ): DOCS \"\"\" A PowerOff message represents a global track power off message. \"\"\" pass class FunctionGroup1 ( Message ): DOCS \"\"\" A FunctionGroup1 message represents a slot function status change. It holds the status for the direction and functions f0 - f4. \"\"\" def __init__ ( self , data = None , slot = None , dir = None , f0 = None , f1 = None , f2 = None , f3 = None , f4 = None , ): if data is None : self . slot = slot self . dir = dir self . f0 = f0 self . f1 = f1 self . f2 = f2 self . f3 = f3 self . f4 = f4 data = bytearray ( 4 ) data [ 0 ] = 0xA1 data [ 1 ] = self . slot data [ 2 ] = 0 data [ 2 ] += 0x20 if self . dir else 0 data [ 2 ] += 0x10 if self . f0 else 0 data [ 2 ] += 0x1 if self . f1 else 0 data [ 2 ] += 0x2 if self . f2 else 0 data [ 2 ] += 0x4 if self . f3 else 0 data [ 2 ] += 0x8 if self . f4 else 0 super () . __init__ ( data ) self . updateChecksum () else : if dir is not None or f0 is not None : raise ValueError ( \"slot and speed arguments cannot be combined with data argument\" ) super () . __init__ ( data ) self . slot = int ( data [ 1 ]) self . dir = bool ( data [ 2 ] & 0x20 ) self . f0 = bool ( data [ 2 ] & 0x10 ) self . f1 = bool ( data [ 2 ] & 0x1 ) self . f2 = bool ( data [ 2 ] & 0x2 ) self . f3 = bool ( data [ 2 ] & 0x4 ) self . f4 = bool ( data [ 2 ] & 0x8 ) def __str__ ( self ): return f \" { self . __class__ . __name__ } (slot = { self . slot } dir: { self . dir } f0: { self . f0 } f1: { self . f1 } f2: { self . f2 } f3: { self . f3 } f4: { self . f4 } | op = { hex ( self . opcode ) } , { self . length =} , data= { list ( map ( hex , map ( int , self . data ))) } )\" class FunctionGroupSound ( Message ): DOCS \"\"\" A FunctionGroupSound message represents a slot function status change. It holds the status for functions f5 - f8. \"\"\" def __init__ ( self , data = None , slot = None , f5 = None , f6 = None , f7 = None , f8 = None ): if data is None : self . slot = slot self . f5 = f5 self . f6 = f6 self . f7 = f7 self . f8 = f8 data = bytearray ( 4 ) data [ 0 ] = 0xA2 data [ 1 ] = self . slot data [ 2 ] = 0 data [ 2 ] += 0x1 if self . f5 else 0 data [ 2 ] += 0x2 if self . f6 else 0 data [ 2 ] += 0x4 if self . f7 else 0 data [ 2 ] += 0x8 if self . f8 else 0 super () . __init__ ( data ) self . updateChecksum () else : if slot is not None or f5 is not None : raise ValueError ( \"slot and function arguments cannot be combined with data argument\" ) super () . __init__ ( data ) self . slot = int ( data [ 1 ]) self . f5 = bool ( data [ 2 ] & 0x1 ) self . f6 = bool ( data [ 2 ] & 0x2 ) self . f7 = bool ( data [ 2 ] & 0x4 ) self . f8 = bool ( data [ 2 ] & 0x8 ) def __str__ ( self ): return f \" { self . __class__ . __name__ } (slot = { self . slot } f5: { self . f5 } f6: { self . f6 } f7: { self . f7 } f8: { self . f8 } | op = { hex ( self . opcode ) } , { self . length =} , data= { list ( map ( hex , map ( int , self . data ))) } )\" class FunctionGroup2 ( Message ): DOCS \"\"\" A FunctionGroup2 message represents a slot function status change. It holds the status for functions f9 - f12. \"\"\" def __init__ ( self , data ): super () . __init__ ( data ) self . slot = int ( data [ 1 ]) self . f9 = bool ( data [ 2 ] & 0x1 ) self . f10 = bool ( data [ 2 ] & 0x2 ) self . f11 = bool ( data [ 2 ] & 0x4 ) self . f12 = bool ( data [ 2 ] & 0x8 ) def __str__ ( self ): return f \" { self . __class__ . __name__ } (slot = { self . slot } f9: { self . f9 } f10: { self . f10 } f11: { self . f11 } f12: { self . f12 } | op = { hex ( self . opcode ) } , { self . length =} , data= { list ( map ( hex , map ( int , self . data ))) } )\" class FunctionGroup3 ( Message ): DOCS \"\"\" A FunctionGroup3 message represents a slot function status change. Depending on the fiegroup, tt holds the status for functions f13 - f19, f21 - f27 or f12 + f20 +f28. \"\"\" def __init__ ( self , data ): super () . __init__ ( data ) # data[1] is always 0x20 self . slot = int ( data [ 2 ]) self . fiegroup = data [ 3 ] if self . fiegroup == 0x08 : self . f13 = bool ( data [ 4 ] & 0x1 ) self . f14 = bool ( data [ 4 ] & 0x2 ) self . f15 = bool ( data [ 4 ] & 0x4 ) self . f16 = bool ( data [ 4 ] & 0x8 ) self . f17 = bool ( data [ 4 ] & 0x10 ) self . f18 = bool ( data [ 4 ] & 0x20 ) self . f19 = bool ( data [ 4 ] & 0x40 ) elif self . fiegroup == 0x09 : self . f21 = bool ( data [ 4 ] & 0x1 ) self . f22 = bool ( data [ 4 ] & 0x2 ) self . f23 = bool ( data [ 4 ] & 0x4 ) self . f24 = bool ( data [ 4 ] & 0x8 ) self . f25 = bool ( data [ 4 ] & 0x10 ) self . f26 = bool ( data [ 4 ] & 0x20 ) self . f27 = bool ( data [ 4 ] & 0x40 ) elif self . fiegroup == 0x05 : self . f12 = bool ( data [ 4 ] & 0x10 ) self . f20 = bool ( data [ 4 ] & 0x20 ) self . f28 = bool ( data [ 4 ] & 0x40 ) def __str__ ( self ): if self . fiegroup == 0x05 : return f \" { self . __class__ . __name__ } (slot = { self . slot } f12: { self . f12 } f20: { self . f20 } f28: { self . f28 } | op = { hex ( self . opcode ) } , { self . length =} , data= { list ( map ( hex , map ( int , self . data ))) } )\" elif self . fiegroup == 0x08 : return f \" { self . __class__ . __name__ } (slot = { self . slot } f13: { self . f13 } f14: { self . f14 } f15: { self . f15 } f16: { self . f16 } f17: { self . f17 } f18: { self . f18 } f19: { self . f19 } | op = { hex ( self . opcode ) } , { self . length =} , data= { list ( map ( hex , map ( int , self . data ))) } )\" elif self . fiegroup == 0x09 : return f \" { self . __class__ . __name__ } (slot = { self . slot } f21: { self . f21 } f22: { self . f22 } f23: { self . f23 } f24: { self . f24 } f25: { self . f25 } f26: { self . f26 } f27: { self . f27 } | op = { hex ( self . opcode ) } , { self . length =} , data= { list ( map ( hex , map ( int , self . data ))) } )\" else : return f \" { self . __class__ . __name__ } (slot = { self . slot } fiegroup: { self . fiegroup } | op = { hex ( self . opcode ) } , { self . length =} , data= { list ( map ( hex , map ( int , self . data ))) } )\" class RequestSwitchFunction ( Message ): DOCS \"\"\" A RequestSwitchFunction message represents a request for a switch status change. It holds the info on whether the switch should be closed or thrown, as well as whether the switch motor should be engaged. \"\"\" def __init__ ( self , data , thrown = None , engage = None ): \"\"\" Construct a RequestSwitchFunction, either from 4 bytes of data or arguments specifying the status for a switch. Args: data (bytearray(4) or int): either 4 bytes of raw data or the switch address thrown (bool, optional): if a switch address is given, this should hold thrown or closed. Defaults to None. engage (bool, optional): if a switch address is given, this should signal whether the motor should be engaged . Defaults to None. \"\"\" \"\"\"\"\"\" if type ( data ) == int : self . address = data data = bytearray ( 4 ) self . opcode = data [ 0 ] = Message . OPC_SW_REP self . thrown = thrown self . engage = engage data [ 1 ] = self . address & 0x7F data [ 2 ] = self . address >> 7 if self . thrown : data [ 2 ] |= 0x20 if self . engage : data [ 2 ] |= 0x10 super () . __init__ ( data ) self . updateChecksum () else : super () . __init__ ( data ) self . address = Message . switchaddress ( data [ 1 ], data [ 2 ]) self . thrown = bool ( data [ 2 ] & 0x20 ) self . engage = bool ( data [ 2 ] & 0x10 ) def __str__ ( self ): return f \" { self . __class__ . __name__ } (addr= { self . address + 1 : 2d } = { self . thrown =} { self . engage =} | op = { hex ( self . opcode ) } , { self . length =} , data= { self . hexdata () } )\" class SwitchState ( Message ): DOCS def __init__ ( self , data ): super () . __init__ ( data ) self . address = Message . switchaddress ( data [ 1 ], data [ 2 ]) self . thrown = bool ( data [ 2 ] & 0x20 ) self . engage = bool ( data [ 2 ] & 0x10 ) def __str__ ( self ): return f \" { self . __class__ . __name__ } (addr= { self . address + 1 : 2d } = { self . thrown =} { self . engage =} | op = { hex ( self . opcode ) } , { self . length =} , data= { self . hexdata () } )\" class RequestSwitchState ( Message ): DOCS def __init__ ( self , id ): if type ( id ) == int : data = bytearray ( 4 ) data [ 0 ] = 0xBC self . address = id data [ 1 ] = id & 0x7F data [ 2 ] = id >> 7 super () . __init__ ( data ) self . updateChecksum () else : super () . __init__ ( id ) self . address = Message . switchaddress ( id [ 1 ], id [ 2 ]) def __str__ ( self ): return f \" { self . __class__ . __name__ } (addr= { self . address + 1 : 2d } | op = { hex ( self . opcode ) } , { self . length =} , data= { self . hexdata () } )\" class SensorState ( Message ): DOCS def __init__ ( self , id ): if type ( id ) == int : data = bytearray ( 4 ) data [ 0 ] = 0xB2 self . address = id data [ 1 ] = ( id >> 1 ) & 0x7F data [ 2 ] = ( id >> 8 ) | ( 0x10 if id % 2 else 0 ) super () . __init__ ( data ) self . updateChecksum () else : super () . __init__ ( id ) self . address = Message . sensoraddress ( id [ 1 ], id [ 2 ]) self . level = bool ( id [ 2 ] & 0x10 ) def __str__ ( self ): return f \" { self . __class__ . __name__ } (addr= { self . address + 1 : 2d } = { ' ON' if self . level else 'OFF' } | op = { hex ( self . opcode ) } , { self . length =} , data= { self . hexdata () } )\" class LongAcknowledge ( Message ): DOCS def __init__ ( self , data ): super () . __init__ ( data ) self . opcode = data [ 1 ] | 0x80 self . ack1 = int ( data [ 2 ]) def __str__ ( self ): return f \" { self . __class__ . __name__ } (reply to opcode = { hex ( self . opcode ) } , ack1 = { self . ack1 } | op = { hex ( self . opcode ) } , { self . length =} , data= { self . hexdata () } )\" class RequestSlotData ( Message ): DOCS def __init__ ( self , slot ): if type ( slot ) == int : data = bytearray ( 4 ) data [ 0 ] = 0xBB data [ 1 ] = self . slot = slot data [ 2 ] = 0 super () . __init__ ( data ) self . updateChecksum () else : super () . __init__ ( slot ) self . slot = int ( slot [ 1 ]) def __str__ ( self ): return f \" { self . __class__ . __name__ } (slot = { self . slot } | op = { hex ( self . opcode ) } , { self . length =} , data= { self . hexdata () } )\" class SlotDataReturn ( Message ): DOCS def __init__ ( self , data ): super () . __init__ ( data ) # data[1] is always 0x0e self . slot = int ( data [ 2 ]) self . status = data [ 3 ] self . address = Message . slotaddress ( data [ 4 ], data [ 9 ]) self . speed = int ( data [ 5 ]) self . dir = bool ( data [ 6 ] & 0x20 ) self . f0 = bool ( data [ 6 ] & 0x10 ) self . f1 = bool ( data [ 6 ] & 0x1 ) self . f2 = bool ( data [ 6 ] & 0x2 ) self . f3 = bool ( data [ 6 ] & 0x4 ) self . f4 = bool ( data [ 6 ] & 0x8 ) self . f5 = bool ( data [ 10 ] & 0x1 ) self . f6 = bool ( data [ 10 ] & 0x2 ) self . f7 = bool ( data [ 10 ] & 0x4 ) self . f8 = bool ( data [ 10 ] & 0x8 ) self . trk = data [ 7 ] self . ss2 = data [ 8 ] self . id1 = data [ 11 ] self . id2 = data [ 12 ] def __str__ ( self ): return f \" { self . __class__ . __name__ } (slot= { self . slot } loc= { self . address } status: { self . status } dir: { self . dir } speed: { self . speed } f0: { self . f0 } f1: { self . f1 } f2: { self . f2 } f3: { self . f3 } f4: { self . f4 } f5: { self . f5 } f6: { self . f6 } f7: { self . f7 } f8: { self . f8 } trk: { self . trk } ss2: { self . ss2 } id1: { self . id1 } id2: { self . id2 } | op = { hex ( self . opcode ) } , { self . length =} , data= { self . hexdata () } )\" class WriteSlotData ( SlotDataReturn ): DOCS def __init__ ( self , slot ): if isinstance ( slot , bytes ) or isinstance ( slot , bytearray ): super () . __init__ ( data ) else : data = bytearray ( 14 ) data [ 0 ] = 0xEF data [ 1 ] = 0x0E data [ 2 ] = slot . slot data [ 3 ] = slot . status data [ 4 ] = slot . address & 0x7F data [ 9 ] = slot . address >> 7 data [ 5 ] = slot . speed data [ 6 ] = 0 data [ 6 ] += 0x20 if slot . dir else 0 data [ 6 ] += 0x10 if slot . f0 else 0 data [ 6 ] += 0x1 if slot . f1 else 0 data [ 6 ] += 0x2 if slot . f2 else 0 data [ 6 ] += 0x4 if slot . f3 else 0 data [ 6 ] += 0x8 if slot . f4 else 0 data [ 7 ] = self . trk data [ 8 ] = self . ss2 data [ 10 ] = 0 data [ 10 ] += 0x1 if slot . f5 else 0 data [ 10 ] += 0x2 if slot . f6 else 0 data [ 10 ] += 0x4 if slot . f7 else 0 data [ 10 ] += 0x8 if slot . f8 else 0 data [ 11 ] = self . id1 data [ 12 ] = self . id2 Message . __init__ ( self , data ) # cannot skip the chain with super() self . updateChecksum () class SlotSpeed ( Message ): DOCS def __init__ ( self , data = None , slot = None , speed = None ): if data is None : self . slot = slot self . speed = speed data = bytearray ( 4 ) data [ 0 ] = 0xA0 data [ 1 ] = slot data [ 2 ] = speed super () . __init__ ( data ) self . updateChecksum () else : if slot is not None or speed is not None : raise ValueError ( \"slot and speed arguments cannot be combined with data argument\" ) self . slot = int ( data [ 1 ]) self . speed = data [ 2 ] super () . __init__ ( data ) def __str__ ( self ): return f \" { self . __class__ . __name__ } (slot= { self . slot } speed: { self . speed } | op = { hex ( self . opcode ) } , { self . length =} , data= { self . hexdata () } )\" class RequestLocAddress ( Message ): DOCS def __init__ ( self , address ): if type ( address ) == int : data = bytearray ( 4 ) data [ 0 ] = 0xBF data [ 1 ] = address & 0x7F data [ 2 ] = address >> 7 self . address = address super () . __init__ ( data ) self . updateChecksum () else : super () . __init__ ( address ) self . address = Message . slotaddress ( address [ 1 ], address [ 2 ]) def __str__ ( self ): return f \" { self . __class__ . __name__ } (address = { self . address } | op = { hex ( self . opcode ) } , { self . length =} , data= { self . hexdata () } )\" class MoveSlots ( Message ): DOCS def __init__ ( self , data = None , src = None , dst = None ): if data is None : self . src = src self . dst = dst data = bytearray ( 4 ) data [ 0 ] = 0xBA data [ 1 ] = self . src data [ 2 ] = self . dst super () . __init__ ( data ) self . updateChecksum () else : if src is not None or dst is not None : raise ValueError ( \"slot arguments cannot be combined with data argument\" ) super () . __init__ ( data ) self . src = int ( data [ 1 ]) self . dst = int ( data [ 2 ]) def __str__ ( self ): return f \" { self . __class__ . __name__ } (src = { self . src } dst = { self . dst } | op = { hex ( self . opcode ) } , { self . length =} , data= { self . hexdata () } )\" class CaptureTimeStamp ( Message ): DOCS def __init__ ( self , t ): if isinstance ( t , time ): data = bytearray ( 6 ) data [ 0 ] = 0xC0 data [ 1 ] = t . hour data [ 2 ] = t . minute data [ 3 ] = t . second data [ 4 ] = t . microsecond // 10000 self . time = t super () . __init__ ( data ) self . updateChecksum () else : super () . __init__ ( t ) self . time = time ( hour = t [ 1 ], minute = t [ 2 ], second = t [ 3 ], microsecond = t [ 4 ] * 10000 )","title":"pylnlib.Message"},{"location":"apidoc/source/pylnlib.Scrollkeeper/","text":"SOURCE CODE pylnlib. Scrollkeeper DOCS # pylnlib : a package to communicate with a model railroad controller using the LocoNet\u00ae protocol # # (c) 2022 Michel Anders (varkenvarken) # # License: GPL 3, see file LICENSE # # Version: 20220716125748 from datetime import datetime from threading import Lock from time import sleep from .Message import ( FunctionGroup1 , FunctionGroup2 , FunctionGroup3 , FunctionGroupSound , MoveSlots , RequestLocAddress , RequestSlotData , RequestSwitchFunction , RequestSwitchState , SensorState , SlotDataReturn , SlotSpeed , SwitchState , ) from .Sensor import Sensor from .Slot import Slot from .Switch import Switch from .Throttle import Throttle class Scrollkeeper : DOCS def __init__ ( self , interface , slottrace = False ): \"\"\" A Scrollkeeper instance keeps track of the state of slots, sensors and switches. A Scrollkeeper instance uses information sent to its messageListener method to keep track of changes to slots, sensors and switches. If it receives messages for which it does not have a Slot, Sensor or Switch instance, it will send requests to get this information. Args: interface (Interface): used to send a message if no information on a particular item is present. slottrace (bool, optional): log every internal update to the console. Defaults to False. \"\"\" self . interface = interface self . slottrace = slottrace self . slots = {} self . slotlock = Lock () self . switches = {} self . switchlock = Lock () self . sensors = {} self . sensorlock = Lock () self . dummy = False def messageListener ( self , msg ) -> None : DOCS \"\"\" Handles incoming messages and updates internal state. If information refering an unknown slot comes in, it will issue a slot status request. Args: msg (Message): An instance of a (subclass of a) Message. \"\"\" if isinstance ( msg , SlotDataReturn ): self . updateSlot ( msg . slot , address = msg . address , dir = msg . dir , speed = msg . speed , f0 = msg . f0 , f1 = msg . f1 , f2 = msg . f2 , f3 = msg . f3 , f4 = msg . f4 , f5 = msg . f5 , f6 = msg . f6 , f7 = msg . f7 , f8 = msg . f8 , status = msg . status , ss2 = msg . ss2 , trk = msg . trk , id1 = msg . id1 , id2 = msg . id2 , ) elif isinstance ( msg , FunctionGroup1 ): if msg . slot not in self . slots : self . sendMessage ( RequestSlotData ( msg . slot )) else : self . updateSlot ( msg . slot , dir = msg . dir , f0 = msg . f0 , f1 = msg . f1 , f2 = msg . f2 , f3 = msg . f3 , f4 = msg . f4 , ) elif isinstance ( msg , FunctionGroupSound ): if msg . slot not in self . slots : self . sendMessage ( RequestSlotData ( msg . slot )) else : self . updateSlot ( msg . slot , f5 = msg . f5 , f6 = msg . f6 , f7 = msg . f7 , f8 = msg . f8 , ) elif isinstance ( msg , FunctionGroup2 ): if msg . slot not in self . slots : self . sendMessage ( RequestSlotData ( msg . slot )) else : self . updateSlot ( msg . slot , f9 = msg . f9 , f10 = msg . f10 , f11 = msg . f11 , f12 = msg . f12 , ) elif isinstance ( msg , FunctionGroup3 ): if msg . slot not in self . slots : self . sendMessage ( RequestSlotData ( msg . slot )) else : if msg . fiegroup == 0x5 : self . updateSlot ( msg . slot , f12 = msg . f12 , f20 = msg . f20 , f28 = msg . f28 ) elif msg . fiegroup == 0x8 : self . updateSlot ( msg . slot , f13 = msg . f13 , f14 = msg . f14 , f15 = msg . f15 , f16 = msg . f16 , f17 = msg . f17 , f18 = msg . f18 , f19 = msg . f19 , ) elif msg . fiegroup == 0x9 : self . updateSlot ( msg . slot , f21 = msg . f21 , f22 = msg . f22 , f23 = msg . f23 , f24 = msg . f24 , f25 = msg . f25 , f26 = msg . f26 , f27 = msg . f27 , ) elif isinstance ( msg , SlotSpeed ): if msg . slot not in self . slots : self . sendMessage ( RequestSlotData ( msg . slot )) else : self . updateSlot ( msg . slot , speed = msg . speed , ) elif isinstance ( msg , SensorState ): self . updateSensor ( msg . address , msg . level ) elif isinstance ( msg , SwitchState ): self . updateSwitch ( msg . address , msg . thrown , msg . engage ) elif isinstance ( msg , RequestSwitchFunction ): self . updateSwitch ( msg . address , msg . thrown , msg . engage ) def updateSlot ( self , id , ** kwargs ) -> None : DOCS \"\"\" Update attributes of a slot. The method is thread safe. Args: id (int): The slot id. \"\"\" with self . slotlock : if id not in self . slots : self . slots [ id ] = Slot ( id ) slot = self . slots [ id ] slot . slot = id for attr , val in kwargs . items (): if dir is not None : setattr ( self , attr , val ) if self . slottrace : print ( self ) def updateSensor ( self , address , level = None ) -> None : DOCS \"\"\" Update the attributes of a sensor. The method is thread safe. Args: address (int): The address of the sensor. This is zero based. level (bool, optional): Either True (on) or False (off). Defaults to None. \"\"\" with self . sensorlock : if address not in self . sensors : self . sensors [ address ] = Sensor ( address ) if level is not None : self . sensors [ address ] . state = level if self . slottrace : print ( self ) def updateSwitch ( self , address , thrown = None , engage = None ): DOCS \"\"\" update the status of a switch. The method is thread safe. Args: address (int): The address of the switch. This is zero based. thrown (bool, optional): direction of the switch. True (thrown, aka Open) or False (closed). Defaults to None. engage (bool, optional): whether the servo is engaged. Defaults to None. \"\"\" with self . switchlock : if address not in self . switches : self . switches [ address ] = Switch ( address ) if thrown is not None : self . switches [ address ] . thrown = thrown if engage is not None : self . switches [ address ] . engage = engage if self . slottrace : print ( self ) def getLocoSlot ( self , address ): DOCS \"\"\" Return the slot id associated with the loc address. If there is no slot known for this loc, request slot data. Args: address (int): loc address Raises: ValueError: if no slot data is available for this loc address Returns: Slot: The Slot instance associated with this loc address. \"\"\" for slot in self . slots : if slot . address == address : return slot if self . dummy : return Slot ( id = 100 , dir = 0 , speed = 0 , status = 0 , address = address ) self . sendMessage ( RequestLocAddress ( address )) if self . waitUntilLocAddressKnown ( address ): for slot in self . slots : if slot . address == address : return slot raise ValueError ( f \"Loc address { address } unknown\" ) def getSwitchState ( self , id ): DOCS \"\"\" Return the state of the switch. if the switch is unknown, request the status. \"\"\" if type ( id ) != int : raise TypeError ( \"Switch id must be an int\" ) if id not in self . switches : self . sendMessage ( RequestSwitchState ( id )) if not self . waitUntilSwitchKnown ( id ): raise ValueError ( \"Switch id {id} unknown\" ) return self . switches [ id ] . thrown def getSensorState ( self , id ): DOCS \"\"\" Return the state of the sensor. if the sensor is unknown, request the status. \"\"\" if type ( id ) != int : raise TypeError ( \"Sensor id must be an int\" ) if id not in self . sensors : self . sendMessage ( SensorState ( id ) ) # request for sensor state is same a sensor state report if not self . waitUntilSensorKnown ( id ): raise ValueError ( f \"Sensor id { id } unknown\" ) return self . sensors [ id ] . level def sendMessage ( self , message ): DOCS \"\"\" place a message in the output queue of the interface. \"\"\" self . interface . sendMessage ( message ) def waitUntilSwitchKnown ( self , id , timeout = 30 ): time_elapsed = 0 while id not in self . switches : sleep ( 0.25 ) time_elapsed += 0.25 if time_elapsed > timeout : return False return True def waitUntilSensorKnown ( self , id , timeout = 30 ): time_elapsed = 0 while id not in self . sensors : sleep ( 0.25 ) time_elapsed += 0.25 if time_elapsed > timeout : return False return True def waitUntilLocAddressKnown ( self , address , timeout = 30 ): time_elapsed = 0 while not any ( slot . address == address for slot in self . slots ): sleep ( 0.25 ) time_elapsed += 0.25 if time_elapsed > timeout : return False return True def acquireSlot ( self , slot ): self . sendMessage ( MoveSlots ( src = slot . id , dst = slot . id )) # TODO: ? should we wait for slot data ? def getThrottle ( self , locaddress ): slot = self . getLocoSlot ( locaddress ) self . acquireSlot ( slot ) return Throttle ( self , locaddress ) def getSlot ( self , id ): return self . slots [ id ] def getSensor ( self , id ): return self . sensors [ id ] def getSwitch ( self , id ): return self . switches [ id ] def getSlotIds ( self ): return [ s for s in self . slots ] def getSensorIds ( self ): return [ s for s in self . sensors ] def getSwitchIds ( self ): return [ s for s in self . switches ] def getAllStatusInfo ( self ): return { \"slots\" : [ self . slots [ s ] . toJSON () for s in sorted ( s for s in self . slots )], \"switches\" : [ self . switches [ s ] . toJSON () for s in sorted ( s for s in self . switches ) ], \"sensors\" : [ self . sensors [ s ] . toJSON () for s in sorted ( s for s in self . sensors ) ], } def __str__ ( self ): newline = \" \\n \" tab = \" \\t \" return f \"\"\" \\033 [2J \\033 [H Scrollkeeper [ { datetime . now () : %H:%M:%S } ] Slots: { newline . join ( tab + str ( self . slots [ s ]) for s in sorted ( s for s in self . slots )) if len ( self . slots ) else tab + '<none>' } Switches: { newline . join ( tab + str ( self . switches [ s ]) for s in sorted ( s for s in self . switches )) if len ( self . switches ) else tab + '<none>' } Sensors: { newline . join ( tab + str ( self . sensors [ s ]) for s in sorted ( s for s in self . sensors )) if len ( self . sensors ) else tab + '<none>' } \"\"\"","title":"pylnlib.Scrollkeeper"},{"location":"apidoc/source/pylnlib.Throttle/","text":"SOURCE CODE pylnlib. Throttle DOCS # pylnlib : a package to communicate with a model railroad controller using the LocoNet\u00ae protocol # # (c) 2022 Michel Anders (varkenvarken) # # License: GPL 3, see file LICENSE # # Version: 20220707161307 from threading import Timer class Throttle : DOCS def __init__ ( self , scrollkeeper , locaddress ): \"\"\" A class to control a single locomotive. Args: scrollkeeper (Scrollkeeper): used to send messages and retrieve slot information locaddress (int): the address of the locomotive \"\"\" self . scrollkeeper = scrollkeeper self . locaddress = locaddress def forward ( self , speed = 0.0 ) -> None : DOCS \"\"\" Changes the speed of a locomotive to forward and a given value. Args: speed (float, optional): speed is a float in the range [0.0, 1.0], setting it to zero will initiate an inertial stop. Defaults to 0.0. Two LocoNet messages may be generated: - Only if the direction is changed: a LocoNet direction message is generated for the slot that controls this loco. - Only if the speed is changed: a LocoNet speed message is generated for the slot that controls this loco. \"\"\" slot = self . scrollkeeper . getSlot ( self . locaddress ) dirchanged = slot . dir != False slot . dir = False speedchanged = slot . speed slot . setSpeed ( speed ) speedchanged = ( speedchanged != slot . speed ) # compare integers; safer than double conversion to/from float if dirchanged : self . scrollkeeper . sendMessage ( slot . dirMessage ()) if speedchanged : self . scrollkeeper . sendMessage ( slot . speedMessage ()) def reverse ( self , speed = 0.0 ) -> None : DOCS \"\"\" Changes the speed of a locomotive to reverse and a given value. Args: speed (float, optional): speed is a float in the range [0.0, 1.0], setting it to zero will initiate an inertial stop. Defaults to 0.0. Two LocoNet messages may be generated: - Only if the direction is changed, a LocoNet direction message is generated for the slot that controls this loco. - Only if the speed is changed, a LocoNet speed message is generated for the slot that controls this loco. \"\"\" slot = self . scrollkeeper . getSlot ( self . locaddress ) dirchanged = slot . dir != True slot . dir = True slot . setSpeed ( speed ) self . scrollkeeper . sendMessage ( slot . slotWriteMessage ()) speedchanged = slot . speed slot . setSpeed ( speed ) speedchanged = ( speedchanged != slot . speed ) # compare integers; safer than double conversion to/from float if dirchanged : self . scrollkeeper . sendMessage ( slot . dirMessage ()) if speedchanged : self . scrollkeeper . sendMessage ( slot . speedMessage ()) def lights ( self , on = True , duration = 0 ) -> None : DOCS \"\"\" Turn directional lights on or off. Args: on (bool, optional): new state of the directional lights. Defaults to True. duration (int, optional): if larger than zero will revert the lights to the previous state after duration seconds. Defaults to 0. \"\"\" slot = self . scrollkeeper . getSlot ( self . locaddress ) msg , imsg = slot . function ( 0 , on , duration ) self . scrollkeeper . sendMessage ( msg ) if duration > 0 : Timer ( duration , self . scrollkeeper . sendMessage , args = [ imsg ]) . start () def sound ( self , on = True , duration = 0 ) -> None : DOCS \"\"\" Turn sound on or off. Args: on (bool, optional): new state of the sound. Defaults to True. duration (int, optional): if larger than zero will revert the sound to the previous state after duration seconds. Defaults to 0. Returns: None \"\"\" slot = self . scrollkeeper . getSlot ( self . locaddress ) msg , imsg = slot . function ( 1 , on , duration ) self . scrollkeeper . sendMessage ( msg ) if duration > 0 : Timer ( duration , self . scrollkeeper . sendMessage , args = [ imsg ]) . start () def whistle ( self , on = True , duration = 0.5 ) -> None : DOCS \"\"\" Sound the whistle. A loc decoder will typically use a short whistle sound that is silent after a short while, but it still needs to be turned off explicitely by the throttle, therefore the function defaults to 0.5 seconds. Args: on (bool, optional): new state of the whistle. Defaults to True. duration (float, optional): if larger than zero will revert the whistle to the previous state after duration seconds. Defaults to 0.5. \"\"\" slot = self . scrollkeeper . getSlot ( self . locaddress ) msg , imsg = slot . function ( 2 , on , duration ) self . scrollkeeper . sendMessage ( msg ) if duration > 0 : Timer ( duration , self . scrollkeeper . sendMessage , args = [ imsg ]) . start ()","title":"pylnlib.Throttle"},{"location":"apidoc/source/pylnlib.Utils/","text":"SOURCE CODE pylnlib. Utils DOCS # pylnlib : a package to communicate with a model railroad controller using the LocoNet\u00ae protocol # # (c) 2022 Michel Anders (varkenvarken) # # License: GPL 3, see file LICENSE # # Version: 20220716124954 import argparse import sys import time from atexit import register from datetime import datetime from .Interface import Interface from .Message import CaptureTimeStamp from .Scrollkeeper import Scrollkeeper # default name of capture file CAPTUREFILE = \"pylnlib.capture\" class Args : DOCS \"\"\" Common command line argument parsing. \"\"\" def __init__ ( self ): cmdline = argparse . ArgumentParser () cmdline . add_argument ( \"-p\" , \"--port\" , help = \"path to serial port\" , default = \"/dev/ttyACM0\" ) cmdline . add_argument ( \"-b\" , \"--baud\" , help = \"baudrate of serial port\" , default = 57600 , type = int ) cmdline . add_argument ( \"-i\" , \"--reportinterval\" , help = \"interval between scrollkeeper reports, or 0 to suppress\" , default = 0 , type = float , ) cmdline . add_argument ( \"-c\" , \"--capture\" , help = f \"capture all traffic to { CAPTUREFILE } \" , action = \"store_true\" , ) cmdline . add_argument ( \"-d\" , \"--dummy\" , help = f \"do not write to serial device\" , action = \"store_true\" , ) cmdline . add_argument ( \"-t\" , \"--timestamp\" , help = f \"add timestamps when writing to a capture file\" , action = \"store_true\" , ) cmdline . add_argument ( \"-l\" , \"--log\" , help = f \"log received message to stderr\" , action = \"store_true\" , ) cmdline . add_argument ( \"-r\" , \"--replay\" , help = f \"replay all captured traffic from { CAPTUREFILE } \" , action = \"store_true\" , ) cmdline . add_argument ( \"-F\" , \"--fast\" , help = f \"ignore timestamps when in replay\" , action = \"store_true\" , ) cmdline . add_argument ( \"-f\" , \"--capturefile\" , help = \"name of capture file\" , default = CAPTUREFILE , type = str , ) cmdline . add_argument ( \"-s\" , \"--slottrace\" , help = f \"show scrollkeeper report after every slot update\" , action = \"store_true\" , ) self . args = cmdline . parse_args () def logger ( msg ): DOCS \"\"\" Write a message with a timestamp to stderr. \"\"\" print ( time . strftime ( \"%H:%M:%S\" ), msg , file = sys . stderr , flush = True ) def dumper ( handle , timestamp = False ): DOCS \"\"\" return a function that writes raw message data to a file. If timestamp is true, it will prefix each message with a [CaptureTimeStamp](pylnlib.Message.CaptureTimeStamp) \"\"\" def dumpmsg ( msg ): if timestamp : handle . write ( CaptureTimeStamp ( datetime . today () . time ()) . data ) handle . write ( msg . data ) return dumpmsg def reporter ( scrollkeeper , interval = 30 ): DOCS \"\"\" return a function that prints the contents of a Scrollkeeper instance at regular intervals. \"\"\" def dump (): while True : print ( scrollkeeper ) time . sleep ( interval ) return dump def createInterface ( args ): DOCS \"\"\" create an [Interface](pylnlib.Interface) object, possibly pointing to a file with previously captured input. \"\"\" capturefile = None if args . replay : capturefile = open ( args . capturefile , \"rb\" ) interface = Interface ( capturefile , fast = args . fast ) else : interface = Interface ( args . port , args . baud , dummy = args . dummy ) if args . log : interface . receiver_handler . append ( logger ) # open a file to write raw captured bytes to if args . capture and not args . replay : capturefile = open ( args . capturefile , \"wb\" , buffering = 0 ) interface . receiver_handler . append ( dumper ( capturefile , timestamp = args . timestamp )) register ( lambda f : f . close (), capturefile ) return interface def createScrollkeeper ( interface , args ): DOCS \"\"\" Create a [Scrollkeeper](pylnlib.Scrollkeeper) instance that receives and sends messages via interface. Args: interface (Interface): The [Interface](pylnlib.Interface) object that the Scrollkeeper will register a receiver_handler with args (Namespace): A Namespace (as returned by Argparser.argse_parse() ). Should have slottrace and dummy attributes. Returns: Scrollkeeper: a [Scrollkeeper](pylnlib.Scrollkeeper) instance. See Also: [Args](pylnlib.Utils.Args) \"\"\" scrollkeeper = Scrollkeeper ( interface , slottrace = args . slottrace ) interface . receiver_handler . append ( scrollkeeper . messageListener ) scrollkeeper . dummy = args . dummy return scrollkeeper","title":"pylnlib.Utils"},{"location":"apidoc/source/pylnlib/","text":"SOURCE CODE pylnlib DOCS # pylnlib : a package to communicate with a model railroad controller using the LocoNet\u00ae protocol # # (c) 2022 Michel Anders (varkenvarken) # # License: GPL 3, see file LICENSE # # Version: 20220710113704 \"\"\" This package can be invoked as a module. Example: ``` python -m pylnlib ``` If invoked this way, it will start listening for data on a serial interface and will report any incoming messages. Incoming messages related to unknown slots, switches or sensors will trigger outgoing status request messages. It can both capture and replay messages. For more info run it with the -- help option ``` python -m pylnlib --help ``` \"\"\"","title":"pylnlib"}]}