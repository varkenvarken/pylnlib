{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pylnlib A python library to monitor LocoNet traffic on a usb/serial bus. table of contents intro goals architecture Message and Interface classes The Scrollkeeper class The Script and Throttle classes The Sensor, Switch and Slot classes dependencies installation example programs capture and replay reference intro I am automating my layout with several Digikeijs components ( DR5000 , DR4024 , DR4088CS ) and I want to be able to script part of the running operation. Now JMRI works fine and even allows for Python scripting, but I find it a bit top heavy on a RaspberryPi 3B+ and also, although this may be a matter of taste, the Python bindings are not very pythonic nor very logical IMHO. Still, a lot of effort went into JMRI and otherwise it is a fine piece of software, but writing my own LocoNet Python library from scratch is not only a nice personal learning experience, but also might allow me to move some of it to microcontrollers with micro Python. goals The functional goals for pylnlib are - be able to monitor all traffic on the usb loconet buffer interface of the DR5000 this includes some extensions like the extended function messages (opcodes a3 and d4) generated by many throttles. to this end classes are provided that represent most messages as well as an UnknownMessage class for messages we do not recognize yet, or are not interested in (like those for CV programming for example) - be able to control switches and locomotives generate messages to change the state of a switch and to change the speed, diection and decoder function of a locomotive. - provide a Script object that simplifies the automated operation of switches and locomotives. non goals and scope There are currently no plans to implement any CV programming options nor do we aim for completeness in controlling locomotives. For example, no functionality is provided to control 'consists'. architecture Pylnlib is designed around the Message and Interface classes. Message and Interface classes Message is subclassed for every implemented LocoNet message (a.k.a. opcode) and Interface communicates over a pyserial interface with the command station. Interface converts incoming raw bytes to (subclasses of) Message instances and converts outgoing Message instance to raw bytes. Interface is thread safe and manages all input and output through two queues. Other class instances, like the Scrollkeeper , can register a callback with an instance of an Interface that will be called for every incoming message. The Scrollkeeper class The Scrollkeeper class is designed to keep track of the layout status. It does this by registering a callback function with an instance of Interface and look at every incoming Message for changes in the status of sensors, switches and slots. Status reply messages are used to update information about the item, just like commands. However if a command (like throwing a switch or changing the contents of a slot to change a locomotive's speed) references an unknown item, the Scrollkeeper instance will send an appropriate status request message. The reply to this message will then be processed as normal. For any item it receieves information about (a sensor, switch, or slot) it creates or updates a suitable object in one of the collections it manages. The Scrollkeeper class also offers methods to provide information about the status of the items it keeps updated and to forward an outgoing Message to an Interface . The Scrollkeeper class is also thread safe, so a single instance could provide information to multiple instances od a Script . Thread safety is maintained by locks on the collections of slots, switches and sensors. The Script and Throttle classes The Script class is used to automate operations on a layout. It holds a reference to a Scrollkeeper instance and provides methods to change locomotive speed, direction and functions, throw swithces as well as wait for a sensor to change to a certain state. The Throttle class is a utility class that encapsulates control of a single locomotive It is instantiated by calling a factory function in the Script class. Instantiation will also reserve a slot for the locomotive if this is not present yet and establish control by issueing a null move on that slot. The Sensor, Switch and Slot classes The Scrollkeeper class maintains several colections of objects that represent the state of an automated object. The Sensor and Switch objects are fairly simple and represent on/off and thrown/closed states respectively. The Slot object is a little more complicated as it carries much more information. It represents a slot on the active LocoNet 'stack'. In the LocoNet model you do not address locomotives directly but instead a collection of slots is kept that contains the current information about locomotives. The command station uses this information the repeatedly send DCC messages to the track. One of the pieces of information in a slot is the decoder address of the locomotiv. Other information that is kept is the diection, speed and the state of the first 9 decoder functions. The Slot class extends this by also storing the state of decoder functions 10 and up. dependencies Python 3.8 pyserial installation pip install pylnlib example programs A simple monitor program can be run directly python \u2013m pylnlib This program can also capture and store the network data to a file and replay this file. For more options type python -m pylnlib --help The scripts directory also contains sample programs that use the library and automate some activities. capture and replay The pylnlib library can also capture raw LocoNet bytes and store it for later replay in a file. This can be really helpful when developing scripts. More details can be found here capture_and_replay.md reference LocoNet personal edition [Pdf] A better formatted version of the above DCC wiki on the electrical side of LocoNet JMRI's constant defintions that include the \u00dchlenbrock extended opcodes","title":"Home"},{"location":"#pylnlib","text":"A python library to monitor LocoNet traffic on a usb/serial bus.","title":"pylnlib"},{"location":"#table-of-contents","text":"intro goals architecture Message and Interface classes The Scrollkeeper class The Script and Throttle classes The Sensor, Switch and Slot classes dependencies installation example programs capture and replay reference","title":"table of contents"},{"location":"#intro","text":"I am automating my layout with several Digikeijs components ( DR5000 , DR4024 , DR4088CS ) and I want to be able to script part of the running operation. Now JMRI works fine and even allows for Python scripting, but I find it a bit top heavy on a RaspberryPi 3B+ and also, although this may be a matter of taste, the Python bindings are not very pythonic nor very logical IMHO. Still, a lot of effort went into JMRI and otherwise it is a fine piece of software, but writing my own LocoNet Python library from scratch is not only a nice personal learning experience, but also might allow me to move some of it to microcontrollers with micro Python.","title":"intro"},{"location":"#goals","text":"The functional goals for pylnlib are - be able to monitor all traffic on the usb loconet buffer interface of the DR5000 this includes some extensions like the extended function messages (opcodes a3 and d4) generated by many throttles. to this end classes are provided that represent most messages as well as an UnknownMessage class for messages we do not recognize yet, or are not interested in (like those for CV programming for example) - be able to control switches and locomotives generate messages to change the state of a switch and to change the speed, diection and decoder function of a locomotive. - provide a Script object that simplifies the automated operation of switches and locomotives.","title":"goals"},{"location":"#non-goals-and-scope","text":"There are currently no plans to implement any CV programming options nor do we aim for completeness in controlling locomotives. For example, no functionality is provided to control 'consists'.","title":"non goals and scope"},{"location":"#architecture","text":"Pylnlib is designed around the Message and Interface classes.","title":"architecture"},{"location":"#message-and-interface-classes","text":"Message is subclassed for every implemented LocoNet message (a.k.a. opcode) and Interface communicates over a pyserial interface with the command station. Interface converts incoming raw bytes to (subclasses of) Message instances and converts outgoing Message instance to raw bytes. Interface is thread safe and manages all input and output through two queues. Other class instances, like the Scrollkeeper , can register a callback with an instance of an Interface that will be called for every incoming message.","title":"Message and Interface classes"},{"location":"#the-scrollkeeper-class","text":"The Scrollkeeper class is designed to keep track of the layout status. It does this by registering a callback function with an instance of Interface and look at every incoming Message for changes in the status of sensors, switches and slots. Status reply messages are used to update information about the item, just like commands. However if a command (like throwing a switch or changing the contents of a slot to change a locomotive's speed) references an unknown item, the Scrollkeeper instance will send an appropriate status request message. The reply to this message will then be processed as normal. For any item it receieves information about (a sensor, switch, or slot) it creates or updates a suitable object in one of the collections it manages. The Scrollkeeper class also offers methods to provide information about the status of the items it keeps updated and to forward an outgoing Message to an Interface . The Scrollkeeper class is also thread safe, so a single instance could provide information to multiple instances od a Script . Thread safety is maintained by locks on the collections of slots, switches and sensors.","title":"The Scrollkeeper class"},{"location":"#the-script-and-throttle-classes","text":"The Script class is used to automate operations on a layout. It holds a reference to a Scrollkeeper instance and provides methods to change locomotive speed, direction and functions, throw swithces as well as wait for a sensor to change to a certain state. The Throttle class is a utility class that encapsulates control of a single locomotive It is instantiated by calling a factory function in the Script class. Instantiation will also reserve a slot for the locomotive if this is not present yet and establish control by issueing a null move on that slot.","title":"The Script and Throttle classes"},{"location":"#the-sensor-switch-and-slot-classes","text":"The Scrollkeeper class maintains several colections of objects that represent the state of an automated object. The Sensor and Switch objects are fairly simple and represent on/off and thrown/closed states respectively. The Slot object is a little more complicated as it carries much more information. It represents a slot on the active LocoNet 'stack'. In the LocoNet model you do not address locomotives directly but instead a collection of slots is kept that contains the current information about locomotives. The command station uses this information the repeatedly send DCC messages to the track. One of the pieces of information in a slot is the decoder address of the locomotiv. Other information that is kept is the diection, speed and the state of the first 9 decoder functions. The Slot class extends this by also storing the state of decoder functions 10 and up.","title":"The Sensor, Switch and Slot classes"},{"location":"#dependencies","text":"Python 3.8 pyserial","title":"dependencies"},{"location":"#installation","text":"pip install pylnlib","title":"installation"},{"location":"#example-programs","text":"A simple monitor program can be run directly python \u2013m pylnlib This program can also capture and store the network data to a file and replay this file. For more options type python -m pylnlib --help The scripts directory also contains sample programs that use the library and automate some activities.","title":"example programs"},{"location":"#capture-and-replay","text":"The pylnlib library can also capture raw LocoNet bytes and store it for later replay in a file. This can be really helpful when developing scripts. More details can be found here capture_and_replay.md","title":"capture and replay"},{"location":"#reference","text":"LocoNet personal edition [Pdf] A better formatted version of the above DCC wiki on the electrical side of LocoNet JMRI's constant defintions that include the \u00dchlenbrock extended opcodes","title":"reference"},{"location":"capture_and_replay/","text":"capture and replay The Interface class can write every incoming and outgoing message as raw bytes to a file. It can also read from this file instead of from a serial port. Not only is this a great help during development because it spares us the effort of running trains again and again just to see activity on the LocoNet bus, it can also help for the same reason when developing scripts that use the library. options The monitoring program has options to enable capturing or replay Capture: python -m pylnlib -c -f capturefile Replay: python -m pylnlib -r -f capturefile Output messages are captured as well but during replay no output is generated. Instead, any captured output is shown as is. This means that we can replay without being connected to a command station. timestamps When capturing you also specify the -t option: python -m pylnlib -c -t -f capturefile This will write a timestamp before every message that is written to the capture file. During replay this timestamp is used to replay the messages in the exact same tempo as they were recorded. The timestamps are written to the capture file as an unused but valid, 6-byte LocoNet message with opcode 0xc0. A corresponding CaptureTimeStamp class is defined to represent this. The 6 bytes of the message are, C0 hh mm ss ff checksum. Where hh, mm and ss represent the hour, minutes and seconds espectively, and ff the fraction of the seconds in hundredths. Without timestamps present, replay will process captured messages as fast as possible.","title":"capture and replay"},{"location":"capture_and_replay/#capture-and-replay","text":"The Interface class can write every incoming and outgoing message as raw bytes to a file. It can also read from this file instead of from a serial port. Not only is this a great help during development because it spares us the effort of running trains again and again just to see activity on the LocoNet bus, it can also help for the same reason when developing scripts that use the library.","title":"capture and replay"},{"location":"capture_and_replay/#options","text":"The monitoring program has options to enable capturing or replay Capture: python -m pylnlib -c -f capturefile Replay: python -m pylnlib -r -f capturefile Output messages are captured as well but during replay no output is generated. Instead, any captured output is shown as is. This means that we can replay without being connected to a command station.","title":"options"},{"location":"capture_and_replay/#timestamps","text":"When capturing you also specify the -t option: python -m pylnlib -c -t -f capturefile This will write a timestamp before every message that is written to the capture file. During replay this timestamp is used to replay the messages in the exact same tempo as they were recorded. The timestamps are written to the capture file as an unused but valid, 6-byte LocoNet message with opcode 0xc0. A corresponding CaptureTimeStamp class is defined to represent this. The 6 bytes of the message are, C0 hh mm ss ff checksum. Where hh, mm and ss represent the hour, minutes and seconds espectively, and ff the fraction of the seconds in hundredths. Without timestamps present, replay will process captured messages as fast as possible.","title":"timestamps"},{"location":"API/pylnlib/","text":"module pylnlib.Throttle class Throttle Summary A class to control a single locomotive. pylnlib . Throttle ( scrollkeeper : Any , locaddress : Any ) -> None Parameters scrollkeeper : Any locaddress : Any method Throttle . forward Summary Change the speed of a locomotive to forward and a given value. Throttle . forward ( speed : float ) -> Any Parameters speed : float (optional) speed is a float [0.0, 1.0], setting it to zero will initiate an inertial stop. Defaults to 0.0. Two LocoNet messages may be generated: - Only if the direction is changed, a LocoNet direction message is generated for the slot that controls this loco. - Only if the speed is changed, a LocoNet speed message is generated for the slot that controls this loco. Returns Any : method Throttle . lights Throttle . lights ( on : Any , duration : Any ) -> Any Parameters on : Any (optional) duration : Any (optional) Returns Any : method Throttle . reverse Summary Change the speed of a locomotive to reverse and a given value. Throttle . reverse ( speed : float ) -> Any Parameters speed : float (optional) speed is a float [0.0, 1.0], setting it to zero will initiate an inertial stop. Defaults to 0.0. Two LocoNet messages may be generated: - Only if the direction is changed, a LocoNet direction message is generated for the slot that controls this loco. - Only if the speed is changed, a LocoNet speed message is generated for the slot that controls this loco. Returns Any : method Throttle . sound Throttle . sound ( on : Any , duration : Any ) -> Any Parameters on : Any (optional) duration : Any (optional) Returns Any : method Throttle . whistle Throttle . whistle ( on : Any , duration : Any ) -> Any Parameters on : Any (optional) duration : Any (optional) Returns Any :","title":"Pylnlib"},{"location":"API/pylnlib/#module-pylnlibthrottle","text":"","title":"module pylnlib.Throttle"},{"location":"API/pylnlib/#class-throttle","text":"","title":"class Throttle"},{"location":"API/pylnlib/#summary","text":"A class to control a single locomotive. pylnlib . Throttle ( scrollkeeper : Any , locaddress : Any ) -> None","title":"Summary"},{"location":"API/pylnlib/#parameters","text":"scrollkeeper : Any locaddress : Any","title":"Parameters"},{"location":"API/pylnlib/#method-throttleforward","text":"","title":"method Throttle.forward"},{"location":"API/pylnlib/#summary_1","text":"Change the speed of a locomotive to forward and a given value. Throttle . forward ( speed : float ) -> Any","title":"Summary"},{"location":"API/pylnlib/#parameters_1","text":"speed : float (optional) speed is a float [0.0, 1.0], setting it to zero will initiate an inertial stop. Defaults to 0.0. Two LocoNet messages may be generated: - Only if the direction is changed, a LocoNet direction message is generated for the slot that controls this loco. - Only if the speed is changed, a LocoNet speed message is generated for the slot that controls this loco.","title":"Parameters"},{"location":"API/pylnlib/#returns","text":"Any :","title":"Returns"},{"location":"API/pylnlib/#method-throttlelights","text":"Throttle . lights ( on : Any , duration : Any ) -> Any","title":"method Throttle.lights"},{"location":"API/pylnlib/#parameters_2","text":"on : Any (optional) duration : Any (optional)","title":"Parameters"},{"location":"API/pylnlib/#returns_1","text":"Any :","title":"Returns"},{"location":"API/pylnlib/#method-throttlereverse","text":"","title":"method Throttle.reverse"},{"location":"API/pylnlib/#summary_2","text":"Change the speed of a locomotive to reverse and a given value. Throttle . reverse ( speed : float ) -> Any","title":"Summary"},{"location":"API/pylnlib/#parameters_3","text":"speed : float (optional) speed is a float [0.0, 1.0], setting it to zero will initiate an inertial stop. Defaults to 0.0. Two LocoNet messages may be generated: - Only if the direction is changed, a LocoNet direction message is generated for the slot that controls this loco. - Only if the speed is changed, a LocoNet speed message is generated for the slot that controls this loco.","title":"Parameters"},{"location":"API/pylnlib/#returns_2","text":"Any :","title":"Returns"},{"location":"API/pylnlib/#method-throttlesound","text":"Throttle . sound ( on : Any , duration : Any ) -> Any","title":"method Throttle.sound"},{"location":"API/pylnlib/#parameters_4","text":"on : Any (optional) duration : Any (optional)","title":"Parameters"},{"location":"API/pylnlib/#returns_3","text":"Any :","title":"Returns"},{"location":"API/pylnlib/#method-throttlewhistle","text":"Throttle . whistle ( on : Any , duration : Any ) -> Any","title":"method Throttle.whistle"},{"location":"API/pylnlib/#parameters_5","text":"on : Any (optional) duration : Any (optional)","title":"Parameters"},{"location":"API/pylnlib/#returns_4","text":"Any :","title":"Returns"}]}